ar#+STARTUP: overview indent num align inlineimages logdone hidestars hideblocks
#+OPTIONS: ^:{}
#+TITLE: 情報処理技法（Javaプログラミング）I
#+AUTHOR: 中鉢 欣秀（非常勤講師）
#+EMAIL: yc@aiit.ac.jp
#+DATE: 2023 春学期
#+OPTIONS: html-style:nil
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://chubachi.net/org-html-themes/src/readtheorg_theme/css/htmlize.css" />
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://chubachi.net/org-html-themes/src/readtheorg_theme/css/readtheorg.css" />
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://chubachi.net/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://chubachi.net/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>

#+begin_comment
- org-publishの設定
  - 下にあるelispを評価すること
- スタイルシート
  - [[https://github.com/fniessen/org-html-themes][fniessen/org-html-themes: How to export Org mode files into awesome HTML in 2 minutes]]
  - note環境がバグっているのでchubachi.netにクローン
- エクスポート
  - M-x org-publish
- ナローイング
  - C-x n s
- サイト
  - https://chubachi.net/lecture-java_1/index.html
  - https://chubachi.net/lecture-java_1/image/program_statements.svg
- tramp
  - [[/scpx:chubachi@chubachi.sakura.ne.jp:www/chubachi.net/lecture-java_1/index.html]]
  - /scpx:chubachi@chubachi.sakura.ne.jp:www/chubachi.net/lecture-java_1/
#+end_comment

#+begin_src emacs-lisp :exports none :results pp
  (setq org-publish-project-alist
        '(("lecture-java1"
           :components ("lecture-java1:orgfiles" "lecture-java1:others"))

          ("lecture-java1:orgfiles"
           :publishing-function org-html-publish-to-html
           :base-directory "~/Dropbox/Org/publish/lecture-java1/"
           :publishing-directory "/scpx:chubachi@chubachi.sakura.ne.jp:~/www/chubachi.net/lecture-java_1/" ;; FIX?
           :base-extension "org"
           :recursive t)

          ("lecture-java1:others"
           :publishing-function org-publish-attachment
           :base-directory "~/Dropbox/Org/publish/lecture-java1/"
           :publishing-directory "/scpx:chubachi@chubachi.sakura.ne.jp:~/www/chubachi.net/lecture-java_1/" ;; FIX?
           :base-extension "png"
           :recursive t)))
;; (setq org-export-use-babel t)
#+end_src

#+RESULTS:
: (("lecture-java1" :components
:   ("lecture-java1:orgfiles" "lecture-java1:others"))
:  ("lecture-java1:orgfiles" :publishing-function org-html-publish-to-html :base-directory "~/Dropbox/Org/publish/lecture-java1/" :publishing-directory "/scpx:chubachi@chubachi.sakura.ne.jp:~/www/chubachi.net/lecture-java_1/" :base-extension "org" :recursive t)
:  ("lecture-java1:others" :publishing-function org-publish-attachment :base-directory "~/Dropbox/Org/publish/lecture-java1/" :publishing-directory "/scpx:chubachi@chubachi.sakura.ne.jp:~/www/chubachi.net/lecture-java_1/" :base-extension "png" :recursive t))

* Java言語の学習方法 :#01:
:PROPERTIES:
:CUSTOM_ID: no_1
:END:

** COMMENT 学習目標

この章の終わりまでに、以下の質問に答えられるようになること。

- [ ] この授業で利用する開発環境とは？
- [ ] Java言語のソースコードの特徴とは？
- [ ] Java言語のキーワードとは？

** はじめに

- この授業では、プログラミングの楽しさ、奥深さ、魅力を学ぶ
- 他のプログラミングにも役立つ、「プログラミングの本質」に迫る
- レベルは初心者に合わせる
- 後期のJava2授業と合わせて履修するのが望ましい

** どうしてJava言語を学ぶのか

- プログラミングを学ぶと何ができるようになるか？
  - アプリが作れるようになる！
- Java言語で作られたアプリ
  - [[https://eng-entrance.com/java_product_summary][【初心者向け】これもJava？ Javaで作れるものまとめてみた]]
- みなさんがITを学ぶ価値
  - ワークライフバランス
  - ライフステージ
  - [[https://coeteco.jp/articles/10618][プログラミング教育必修化のすべてがわかる！まるわかりガイド | コエテコ]]

** Javaの開発環境（repl.it）

- Java言語でプログラミングを書く基本的な環境
  - [[https://www.oracle.com/java/technologies/downloads/][Java Downloads | Oracle]]
  - ソースコードを書くためのテキストエディタ
- 統合開発環境（IDE）
  - [[https://azure.microsoft.com/ja-jp/products/visual-studio-code/][Visual Studio Code – コード エディター | Microsoft Azure]]
  - [[https://www.eclipse.org/downloads/][Eclipse Downloads | The Eclipse Foundation]]
- クラウド型環境
  - [[https://replit.com/~][Home - Replit]]
- Replit（れぷるいと）とは？
  - repl.itとはWebブラウザのみで完結するプログラミング環境
  - 多くのプログラミング言語で利用可能（この授業ではJava）
- Replitを使って演習や課題を行う → *使えるようになろう！*

** Javaの公式ドキュメント

- Javaの開発を行っている会社
  - [[https://www.oracle.com/index.html][Oracle | Cloud Applications and Cloud Platform]]
- 最新のJavaのバージョン
  - Java SE 18 Edition
- Java開発環境に関する文書
  - [[https://docs.oracle.com/en/java/javase/18/index.html][JDK 18 Documentation - Home]]
- Java言語の仕様書
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/index.html][The Java® Language Specification]]

** Java言語のソースコード

簡単なJava言語のコードを見てみよう。

#+begin_src java -n :results output
  class Main {
    public static void main(String[] args) {
      System.out.println("Hello World");
    }
  }
#+end_src

#+RESULTS:
: Hello World

これは *標準出力* に「Hello World」という *文字列* を出力（表示）するプログラムである。

なお、行頭の番号（「1:」等）は行番号であり、実際のプログラムには書かない。

ちなみに、同じプログラムをC言語で書くと、

#+begin_src C -n :results output
  #include <stdio.h>
  void main() {
    printf("Hello World\n");
  }
#+end_src

#+RESULTS:

ちなみに、同じプログラムをPythonで書くと、

#+begin_src python -n :results output
  print('Hello World')
#+end_src

#+RESULTS:
: Hello World

ちなみに、同じプログラムをRubyで書くと、

#+begin_src ruby -n :results output
  p "Hello World"
#+end_src

#+RESULTS:
: "Hello World"

** Java言語の「キーワード」

もう一度、先程のJava言語のコードを見てみよう。

#+begin_src java -n :results output
  class Main {
    public static void main(String[] args) {
      System.out.println("Hello World");
    }
  }
#+end_src

#+RESULTS:
: Hello World

プログラムに出てくるclass, public, static, void などは [[https://docs.oracle.com/javase/specs/jls/se17/html/jls-3.html#jls-3.9][Keywords]] と呼ばれ、どれも重要な意味がある。

しかし、これらの keyword の意味を理解するためには、Java言語をある程度学んでからでなくては難しい。このため、この授業では最小限度の解説に止める。

なお、keywordは予約語（Reserved word)とも言う。Java言語本体が利用することが予約されており、自分のプログラムの変数名、関数名等に利用することはできないことを、覚えておこう。

** いまはテンプレートとして考えよう

- class等の予約語を理解するのは後まわしにし、テンプレートとして利用してみよう。

#+begin_src java -n :results output
  class Main {
    public static void main(String[] args) {
      System.out.println("JavaプログラムI");
    }
  }
#+end_src

#+RESULTS:
: JavaプログラムI

- このように、コードの3行目を変更することで、別の文字列が出力される。
- 別の例をみよう。

#+begin_src java -n :results output
  class Main {
    public static void main(String[] args) {
      System.out.println("情報処理技法");
      System.out.println(1 + 2);
      System.out.println(Math.PI);
      System.out.println(new StringBuilder("情報処理技法").reverse());
    }
  }
#+end_src

#+RESULTS:
: 情報処理技法
: 法技理処報情
: 3
: 3.141592653589793

- このように、プログラムには *複数の行を書く* ことができる。

* 字句構造：プログラミングの基礎知識 :#02:
** 追加資料

- 日本語資料としておすすめ
  - [[https://java-code.jp/][Javaコード入門]]

** プログラムに使う文字（Unicode）
*** テキストファイルとUnicode

- プログラムはテキストファイルで作成
  - 「テキスト＝文字」からなるファイル

- 文字コード（文字を数値で扱うための決まり）
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.1][3.1. Unicode]]
  - [[https://home.unicode.org/][Unicode – The World Standard for Text and Emoji]]

#+begin_comment
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.2][Chapter 3. Lexical Structure]]
#+end_comment

*** キーボードにある記号の読み方

| 記号   | 一般的な読み方                               | 英語スペル                     | JIS規格の名称                                      |
|--------+----------------------------------------------+--------------------------------+----------------------------------------------------|
| (      | *開き括弧* （かっこ）                          | left paren、open parenthesis   | 左小括弧                                           |
| )      | *閉じ括弧* （こっか）                          | right paren、close parenthesis | 右小括弧                                           |
| {      | *開き中括弧*                                   | left brace、open brace         | 左中括弧                                           |
| }      | *閉じ中括弧*                                   | right brace、close brace       | 右中括弧                                           |
| [      | *開き大括弧*                                   | left bracket、open bracket     | 左大括弧                                           |
| ]      | *閉じ大括弧*                                   | right bracket、close bracket   | 右大括弧                                           |
|--------+----------------------------------------------+--------------------------------+----------------------------------------------------|
| =      | *イコール*                                     | equals                         | 等号                                               |
| +      | *プラス*                                       | plus                           | 正符号                                             |
| -      | *マイナス* 、ハイフン、ダッシュ （本当は別物） | hyphen、dash                   | ハイフン、負符号                                   |
| *      | アスタリスク *スター* コメ印 掛算記号          | asterisk                       | アスタリスク                                       |
| ／     | *スラッシュ* 、割算記号                        | slash                          | 斜線                                               |
| ＼(￥) | *バックスラッシュ*                             | backslash                      | 円記号                                             |
|--------+----------------------------------------------+--------------------------------+----------------------------------------------------|
| <      | *小なり記号*                                   | less than                      | 不等号（より小）                                   |
| >      | *大なり記号*                                   | greater than                   | 不等号（より大）                                   |
|--------+----------------------------------------------+--------------------------------+----------------------------------------------------|
| '      | *シングルクウォート* 、アポストロフィ、ちょん  | single quote                   | シングルクォート、アポストロフィー（本来は別もの） |
| `      | *バッククオート*                               | back quote                     | アクサングラーブ                                   |
| "      | *ダブルクォート* 、ちょんちょん                | double quote                   | 引用符                                             |
|--------+----------------------------------------------+--------------------------------+----------------------------------------------------|
| ,      | *カンマ*                                       | comma                          | コンマ、セディユ                                   |
| .      | *ピリオド* 、 *ドット* 、ポイント                | period、dot、point             | 終止符                                             |
| ;      | *セミコロン*                                   | semicolon                      | セミコロン                                         |
| :      | *コロン*                                       | colon                          | コロン                                             |
| ?      | *はてな記号* 、クエスチョン・マーク            | question mark                  | 疑問符                                             |
| !      | *びっくり記号*                                 | exclamation                    | 感嘆符                                             |
|--------+----------------------------------------------+--------------------------------+----------------------------------------------------|
| #      | *シャープ記号* 、ナンバー、ハッシュ            | number sign、pound sign、hash  | 番号記号、井桁（いげた）                           |
| $      | *ドル記号*                                     | dollar sign                    | ドル記号                                           |
| %      | *パーセント*                                   | percent                        | パーセント                                         |
| &      | *アンド記号* 、アンパサンド                    | ampersand、and sign            | アンパサンド                                       |
| ~      | *チルダ* 、にょろ記号                          | tilde                          | 波線、波線符号                                     |
| _      | *アンダースコア*                               | underscore                     | アンダライン                                       |
| ^      | *ハット* 、サーカムフレックス                  | hat, circumflex                | アクサンシルコンフレックス、キャロット             |
| \vert      | バー *縦棒*                                    | vertical bar                   | 縦線                                               |

- [[http://capm-network.com/?tag=%E3%82%AD%E3%83%BC%E3%83%9C%E3%83%BC%E3%83%89%E7%89%B9%E6%AE%8A%E8%A8%98%E5%8F%B7%E3%81%AE%E8%AA%AD%E3%81%BF%E6%96%B9][キーボード特殊記号の読み方 CapmNetwork]]

*** 改行文字

- プログラムは複数の行からなる
  - 1行は「改行文字」で終わる（[[https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.4][3.4.Line Terminators]]）
- 改行文字は目で見えないが、そこにあるもの
  - <CR>…改行文字

#+begin_example
  abc<CR>
  defgh<CR>
  ij<CR>
#+end_example

- 改行の入力
  - キーボードのEnterキー
- 改行の削除
  - BSキー

*** 空白文字

- 空白は目に見えない文字
  - _…空白文字

#+begin_example
  __abc<CR>
  ___de_fgh<CR>
  _i_j_<CR>
#+end_example

- 空白文字は改行文字を含む
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.6][3.6.White Space]]

- 空白の利用目的
  - 単語を区切る
  - プログラムを見やすく整える

- タブ（TAB）
  - 8文字毎に桁を揃える特殊な空白
    - 4文字や2文字のことも
    - 近年は使わないことが望ましい

** コメント（Comments）

- プログラムに自然言語（日本語や英語など）で [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.7][3.7.Comments]] を記述できる
  - コメントは人間が読むためのものであり、コンピュータは読み飛ばす
  - コメントを適切に書くことで、 *人間* が読みやすいプログラムになる

- コメントの書き方は2通りある
  1. 行コメント
  2. 範囲コメント

#+begin_src java -n :results output
  class Main {
    public static void main(String[] args) {
      // この行はコメント

      /*
        この
        範囲は
        コメント
      ,*/

      // System.out.println("表示されません");
      // System.out.println("これも表示されません");
    }
  }
#+end_src

#+RESULTS:

- 書きやすいので、複数行のコメントでも行コメントを使うことが多い

- ちなみに、pythonには行コメントのみ

#+begin_src python
  # comment
  a = 1  # comment
#+end_src

#+RESULTS:
: None

- ちなみに、rubyの場合
  - 範囲コメントはあるが、使うのは稀

#+begin_src ruby :results output
  # comment
  p 123

  =begin
  p 'ABC'
  p 'DEF'
  =end

  p 456 # comment
#+end_src

#+RESULTS:
: 123
: 456

** 識別子（Identifier）
*** 識別子（Identifier）とは

- あるモノと、他のモノとを区別できるようにするための仕組み

- 識別子の具体例
  - 電話番号
  - 学籍番号
  - 銀行の口座番号
  - メールアドレス など

- 普段利用している「名前」は識別子になるか？
  - 同姓同名！
  - 新宿駅！

- 識別子は情報処理システムで情報を扱う場合に、重要な概念の一つ
  - ある情報と他の情報を区別するために必要

*** プログラミングと識別子

- プログラムではある概念（変数やデータの種類、関数など）を扱うために名前を使う
- 名前は単なる名前ではなく、識別子である
  - appleとringo
- ある識別子が他の識別子と同じであると判断されるためには、一字一句同じ名前である必要がある
- 逆に言えば、一字一句同じ名前であれば、それらは「同じもの」である
  - 似たような概念であっても別なものとして扱いたい場合は、必ず別の名前をつけなくてはならない
    - apple1
    - apple2
    - apple3

*** 識別子の使い方

- 予め定義されている識別子
  - プログラミング言語が予め定義している名前（予約語）
- プログラマーが新たに定義する識別子
  - 何らかの情報につける名前（＝変数名など）
  - 何らかの処理につける名前（＝関数名など）
- 識別子はその意味を定義してから使う
  - 意味の定義の仕方はプログラミング言語によって様々

* 字句構造：プログラミングの表記法 :#03:
** 記号・区切り文字・演算子
*** Javaの識別子（Identifier）とキーワード（Keywords）
**** Javaの識別子

- Javaの識別子の仕様
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.8][3.8.Identifiers]]
- 識別子には利用できる文字が決められている
  - 最初の文字は数字以外
    - 大文字A〜Zと小文字a〜z（大文字と小文字は *区別される* ）
    - アンダースコア（_）も使えるが、普通は利用しない
    - その他のUnicode文字も利用可能（日本語も）
  - 2番目の文字以降は数字も使用できる
    - 0〜9
  - 文字数に制限はない

# なお、Javaでは識別子のことをシンボル（Symbol）とも呼ぶ

#+begin_example
 a    // OK
 abc  // OK
 a0   // OK
 B1C2 // OK
 1    // NG
 1a   // NG
#+end_example

**** Javaのキーワード

- Javaのキーワード（予約語）の仕様
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.9][3.9.Keywords]]

*** 参考：紛らわしい文字と数字
**** 似てる文字の悪夢

- 似ている文字
  - 0とOとo
  - bと6
  - 1と7とlとIと!
  - gと9とq
  - aとoとe
  - mとrn
  - ‘と”と` などなど

- 例
  - 「Al（男性名アル）」と「AI（人工知能）」
  - 「burn（やけど）」と「bum（浮浪者）」
  - 「boat（ボート）」と「boot（靴）」

**** スペルミス

- 一見同じに見えるけど（スペルミス・大文字小文字の悪夢）
  - Hello Hallo Halo
  - print と plint
  - system と sistem
  - Japan と japan
  - JAVAとJava

**** 同じ？違う？

- 次の中で「東京女子大」と書かれているものはどれか？
  - Tokyojoshidai
  - Tokyouzyosidai
  - Toukyoujoshiidai

- 中鉢（ちゅうばち）をローマ字で書いたとき、正しいのは？
  - Chubachi
  - Tyuubati
  - Chuubati

- 本屋
  - honnya
  - hon'ya

**** 全角・半角問題

- 日本語特有の問題
  - 「あい うえお」と「あい　うえお」
  - @マークと＠マーク
  - ”こんにちは” と“こんにちは”
  - To_Do と To＿Do

*** 区切り文字（Separators)

- 仕様
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.11][3.11. Separators]]
- これらはプログラムの文字列の区切りを表す。
  - プログラムそのものも文字列でできている。

#+begin_example
(   )   {   }   [   ]   ;   ,   .   ...   @   ::
#+end_example

- abc <=> a,b,c <=> a,bc

- 例えば，次の文字列は

  #+begin_example
  abc.def(gh[10],ijk[-2]);
  #+end_example

- 次の通り区切って取り扱われる。

  #+begin_example
  abc
  .
  def
  (
  gh
  [
  10
  ]
  ,
  ijk
  [
  -2
  ]
  )
  ;
  #+end_example

*** 演算子（Operators）

- 仕様
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.12][3.12.Operators]]
- 1つ以上の記号を組み合わせた、異なる意味を持つ演算子が定められている。
  - 例

    | 演算子 | 意味         |
    | =      | 代入         |
    | ==     | 等しい       |
    | >      | 〜より大きい |
    | <=     | 以下         |
    | %      | 割算の余り   |

*** 区切り文字と空白文字

- 区切り文字の効果
  - abc <=> a,b,c <=> a,bc

- 前節の区切り文字とあわせ、次のプログラムは

#+begin_example
a=0;if(a>=-10){return(3.14);}
#+end_example

- 次の通り区切られる（プログラムの意味は気にしないこと）

#+begin_example
a
=
0
;
if
(a
>=
-10
)
{
return
(
3
.
14
)
}
;
#+end_example

- なお、「3/./14」はひと塊で意味を持つ数値であるので、
  実際には「3.14」として取り扱われる。

- 次の通り、区切り文字の前後には好きなだけ
  空白文字（[[https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.6][3.6. White Space]]）を入れることができる。
  - ただし、「3.14」 のピリオドの前後には入れられないなど、
    例外はある

#+begin_src java -n :results output
System.out.println(3.14);
#+end_src

#+RESULTS:
: 3.14

- とても自由に空白文字を入れても動作する

#+begin_src java -n :results output
System
  .
    out

   .println
   (
3.14
              );
#+end_src

#+RESULTS:
: 3.14

- ちなみに、pythonの場合

#+begin_src python :results output
  print(
   "pi="
     + str(3.14
       ))
#+end_src

#+RESULTS:
: pi=3.14


#+begin_src python :results output
print (  "pi=" +str( 3.14  ) )
#+end_src

#+RESULTS:
: pi=3.14

# begin_warningも使えるよ

#+begin_note
Javaの一文は、セミコロンで終了する。このことにより、
Javaでは比較的自由に改行や空白を入れることができる。

なお、改行や空白が自由に使えることは、プログラムを書く人によって
スタイルがばらばらになるというデメリットも発生する。
#+end_note

** 文（Statement）

- 仕様
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-14.html#jls-14.5][14.5.Statements]]
- プログラムはいくつかの文からなる
  - Javaでは、文を「;」で区切る（日本語の「。」と同じ感覚）
- 文の例
  - System.out.println(“...”);
  - int i = 0;
  - ruturn;

#+CAPTION: プログラムはいくつかの文からなる
#+NAME: fig-program_statements1
[[./image/program_statements.png]]

** 複合文（Block statement）

- いくつかの文をまとめてブロックにすることができる（複合文：Block statement）

#+CAPTION: プログラムはいくつかのブロックからなる
#+NAME: fig-program_statements2
[[./image/block_statement.png]]

- ブロックの中にブロックを作ることができる
  - 入れ子構造（Nested Structure）
    - 入れ子構造はプログラムの基本構造である
  - プログラムはブロック（Block）（とStatement）を入れ子構造にして構成する

- Javaでは「{」と「}」でブロックを作る
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-14.html#jls-14.2][14.2. Blocks]]

#+begin_src java :results output
  //  1   2   3
  {
      System.out.println("block1");
  }
  {
      System.out.println("block2");
  }
  {
      System.out.println("block3");
      {
          System.out.println("block3-1");
      }
      {
          System.out.println("block3-2");
      }
  }
  {
      System.out.println("block4");
      {
          System.out.println("block4-1");
          {
              System.out.println("block4-1-1");
          }
          {
              System.out.println("block4-1-2");
              {
                  System.out.println("block4-1-2-1");
              }
          }
      }
      {
          System.out.println("block4-2");
      }
  }
#+end_src

#+RESULTS:
#+begin_example
block1
block2
block3
block3-1
block3-2
block4
block4-1
block4-1-1
block4-1-2
block4-1-2-1
block4-2
#+end_example

#+CAPTION: 入れ子構造
#+NAME: fig-program_statements3
[[./image/nested_structure.png]]

** 字下げ（indent）の重要性

  - 先程の入れ子構造のプログラムはこの様に書くこと「も」できる。

#+begin_src java -n :results output
  {System.out.println("block1");}{System.out.println("block2");}{System.out.println("block3");{System.out.println("block3-1");}{System.out.println("block3-2");}}{System.out.println("block4");{System.out.println("block4-1");{System.out.println("block4-1-1");}{System.out.println("block4-1-2");{System.out.println("block4-1-2-1");}}}{System.out.println("block4-2");}}
#+end_src

#+RESULTS:
#+begin_example
block1
block2
block3
block3-1
block3-2
block4
block4-1
block4-1-1
block4-1-2
block4-1-2-1
block4-2
#+end_example

- 字下げを適切に用いないと、プログラムの入れ子構造はとてもとても分かりにくくなる。
  - 字下げを正しく記述しないとエラーとなるプログラミング言語（python）もあるが、Javaでは自分で正しく字下げをする必要がある。
  - この授業では、1段階の字下げを空白2文字分とする。
  - 字下げが理解でき、正しくできるようになるかどうかが、プログラミングを習得できるかどうかの鍵になる（と言っても過言ではない）

- Pythonの場合
  - インデントでブロックを表す

  #+begin_src python :results output
    def fibonacci_iter(n):
        a=1
        b=1
        if n==1:
            print('0')
        elif n==2:
            print('0','1')
        else:
            print('0')
            print(a)
            print(b)
            for i in range(n-3):
                total = a + b
                b=a
                a= total
                print(total)

    fibonacci_iter(8)
  #+end_src

  #+RESULTS:
  : 0
  : 1
  : 1
  : 2
  : 3
  : 5
  : 8
  : 13

- Rubyの場合
  - def ~ end, for ~ end など
  - { } を用いる場合もある

  #+begin_src ruby :results output
    def num(n)
      return 1 if n == 1
      return 1 if n == 2
      num(n-1) + num(n-2)
    end

    for i in 1..40
      print "#{num(i)} "
    end
  #+end_src

  #+RESULTS:

** プログラムはブロックの組み合わせ

- プログラムは「積み木」のようにブロックを組み合わせて作成する
- 一つ一つのブロックは何らかの意味のまとまりを持つ
- 小さな積み木をどんどん積み重ね、大きなプログラムにする

* 字句構造：型と様々な直値 :#04:
** 情報量と型
*** 情報量（bit）のおさらい
:PROPERTIES:
:CUSTOM_ID: 情報量bitのおさらい
:END:

- 2進数で整数を扱う場合

| bit数 | 扱える情報の個数             | 正の整数とすると                | 負の整数も扱うなら                                     | 扱える情報の例             |
|     1 | 2こ                          | 0,1                             | -1,0                                                   | 真と偽/yes no/true false   |
|     2 | 4こ                          | 0,1,2,3                         | -2,-1,0,1                                              | 方位                       |
|     3 | 8こ                          | 0,1,2,3,4,5,6,7                 | -4, -3, -2, -1, 0, 1, 2, 3                             | 月，火，水，木，金，土，日 |
|     4 | 16こ                         | 0～15                           | -8～7                                                  | 十二支                     |
|     8 | 256こ                        | 0～255                          | -128～127                                              | A～Z、a～z、数字、記号     |
|    16 | 65536こ                      | 0～65535                        | -32,768～32,767                                        | よく使う日本語の文字       |
|    32 | 42億9496万7296こ             | 0～4,294,967,295                | -2,147,483,648～2,147,483,647                          | 地球の年齢には少し足りない |
|    64 | 1844京6744兆737億955万1616こ | 0 ～ 18,446,744,073,709,551,615 | -9,223,372,036,854,775,808 ～9,223,372,036,854,775,807 | とても大きな数・・・       |

- 2進数で実数を扱う場合

| bit数 | 名称             | 表現できる範囲            | 精度（参考）     | 扱える情報の例                               |
|    32 | 単精度浮動小数点 | およそ±10^{-38} 〜 ±10^{38}   | 10進数で7桁程度  | とてもとても大きな数からとてもとても小さな数 |
|    64 | 倍精度浮動小数点 | およそ±10^{-308} 〜 ±10^{308} | 10進数で16桁程度 | とてもとてもとてもとても・・・（以下略       |

*** 「型（type）」とは何か
:PROPERTIES:
:CUSTOM_ID: 型typeとは何か
:END:

- [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-4.html][Chapter 4. Types, Values, and Variables]]

- プログラムで情報を扱いたいとき、単にbit数だけを決めても不十分
  - bit数で扱える情報の個数は決まる
  - ただしその情報の扱い方を別途決めておかなくてはならない
    - 正の整数として見るのか
    - 負の整数として見るのか
    - 実数（浮動小数点数）としてみるのか
    - （更に言えば、画像として扱うのか、音声として扱うのか・・・・）
- プログラムでは情報の量やその取り扱い方をまとめて「型（Type）」と言う

*** Javaの基本型（primitive type）
:PROPERTIES:
:ID:       7a14f8e2-ac0f-4fd0-86ad-e5e0121b8781
:END:

- 基本型
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-4.html#jls-4.2][4.2. Primitive Types and Values]]

- 基本型の名前の最初の文字は「アルファベット小文字」になっている

| データ型                        |               bit数 | 範囲                                      |
| boolean（ブーリアン）           | 1（本当は違うけど） | true / false （トゥルー・フォルス）       |
| byte（バイト）                  |                   8 | -128～127                                 |
| short（ショート）               |                  16 | -32768～32767                             |
| int（インテジャー or イント）   |                  32 | -2147483648～2147483647                   |
| long（ロング）                  |                  64 | -9223372036854775808～9223372036854775807 |
| float（フロート）               |                  32 | 単精度浮動小数点数                        |
| double（ダブル）                |                  64 | 倍精度浮動小数点数                        |
| char（キャラクター or　チャー） |                  16 | Unicode文字 （\u0000～\uFFFF）            |
| void（ボイド）                  |                 --- | （型が）無い ※特殊                       |

*** 参照型

Javaでは基本型の他に「参照型（ReferenceType）」がある。イメージとして、基本型を組み合わせて参照型を作る。言わば、基本型に対する応用型である。更に、参照型は他の参照型を組み合わせることもできるので、複雑な情報を取り扱うことができる。


** 数値の直値
*** 数値（Value）の書き方
:PROPERTIES:
:CUSTOM_ID: 型を持つ数値の書き方
:END:

- 「数字（number）」と「数値（value）」の違い
  - 数字は文字、数値は値

- 数値をプログラムに書く
  - 数字、ピリオド、マイナス記号等を用いて直接書く（＝直値）

- 直値（literal）
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.10][3.10.Literals]]

- 数値の直値にも「型」がある

*** 整数型

- int型整数（デフォルト）
  - 1
  - -123
  - 3776

#+begin_src java :results output
    System.out.println(1);
    System.out.println(-123);
    System.out.println(3776);
    System.out.println(1234567890);
    System.out.println(2147483647);
    // System.out.println(2147483648);
#+end_src

- long型整数（アルファベットのLをつける）
  - 1 *L*
  - 12345678901234567890123456789 *L*

#+begin_src java :results output
        System.out.println(2147483648L);
        System.out.println(1234567890123456789L);
        System.out.println(9223372036854775807L);
        // System.out.println(9223372036854775808L);
#+end_src

#+RESULTS:
: 2147483648
: 1234567890123456789
: 9223372036854775807

- Lをつけないとエラー。

#+begin_src java :results output
class Main {
  public static void main(String[] args) {
    System.out.println(2147483648L);
  }
}
#+end_src

*** 実数型

- double型実数（デフォルト：Dをつけてもつけなくても構わない）
  - 1.0
  - -3.1415926534
  - .375 （1の位が0なら省略できる）
  - 6.02214076E+23 （アボガドロ定数6.02214076✕10^{23}の浮動小数点表記）

#+begin_src java -n :results output
  System.out.println(1.0);
  System.out.println(-3.1415926534);
  System.out.println(.375);
  System.out.println(6.02214076E+23);
#+end_src

#+RESULTS:
: -1.0
: 3.14
: 3.141592
: 1.0
: -3.1415926534
: 0.375
: 6.02214076E23

- float型実数（アルファベットのFをつける）
  - -1.0F
  - 3.14F
  - 3.141592F

#+begin_src java -n :results output
    System.out.println(-1.0F);
    System.out.println(3.14F);
    System.out.println(3.141592F);
#+end_src

  ,#+RESULTS:
  : -1.0
  : 3.14
  : 3.141592
  : 1.0
  : -3.1415926534
  : 0.375
  : 6.02214076E23

#+begin_note
  要するに、数字の他にピリオドがなければint、あればdoubleと扱われると覚えれば良い。
#+end_note

#+begin_src java :results output
  class Main {
    public static void main(String[] args) {
      System.out.println(1E+2); // 1*10^2 = 1*100 = 100
      System.out.println(1E+1); // 1*10^1 = 1*10 = 10
      System.out.println(1E+0); // 1*10^0 = 1*1 = 1
      System.out.println(1E-1); // 1*10^(-1) = 1*0.1 = 0.1
      System.out.println(1E-2); // 1*10^(-2) = 1*0.1 = 0.01

      System.out.println(6.02214076E+23);
    }
  }
#+end_src

** 真偽値の直値                                                        :#05:
*** 真偽値型

- 真偽値型
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.10.3][3.10.3. Boolean Literals]]

- 書き方
  - =true=
  - =false=

#+begin_src java -n :results output
  System.out.println(true);
  System.out.println(false);
#+end_src

#+RESULTS:

** 文字の直値
*** 文字の直値
:PROPERTIES:
:CUSTOM_ID: 文字の直値
:END:

- 文字の直値
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.10.4][3.10.4. Character Literals]]

- 文字の直値はシングル・クォーテーション記号で囲む
  - char型
    - 'a'  「a」という文字（半角）
    - '字' 「字」という文字（全角）
    - '华'  中国語簡体字の文字（「華」）

#+begin_src java -n :results output
  System.out.println('a');
  System.out.println('字');
  System.out.println('华');
#+end_src

#+RESULTS:
: a
: 字
: 华

#+begin_note
「文字」と「文字列」は異なる！文字は1文字だけ。文字列は何文字でも。普段のプログラミングでは圧倒的に文字「列」を使うことが多い（後述）。
#+end_note

*** 文字の直値とエスケープシークエンス
:PROPERTIES:
:CUSTOM_ID: 文字の直値とエスケープシークエンス
:END:

- エスケーシーケンス
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.10.7][3.10.7.Escape Sequences]]

- 文字は「シングルクォーテーション」で囲むという規則のとき、
  - 「 ='= 」という文字（シングルクォーテーション）自体はどうあらわす？
- ='''= こんな書き方はできない！
  - 2つ目のシングルクォーテーションが *文字の終わり* を示してしまいエラーとなる

#+begin_src java -n :results output
  System.out.println('''); // Error!
#+end_src

- 「文字の終わりじゃなくって、 シングルクォーテーションという文字である」こと示すために、 *エスケープ・シークエンス（escape sequence）* を使う
  - エスケープとは、「何らかの意味」から「免れる」こと
  - 「文字の終わり」という意味を打ち消す
- シングルクォーテーションをエスケープ・シーケンスで表す方法
  - ='\''= バックスラッシュ＋シングルクォーテーション

#+begin_src java -n :results output
  System.out.println('\''); // OK
#+end_src

#+RESULTS:
: '

- すると、「 =\= （バックスラッシュ）」記号自体はどう表すの？
  - ='\\'=      バックスラッシュ＋バックスラッシュ

#+begin_src java -n :results output
  System.out.println('\\'); // OK
#+end_src

- これは良い仕組みだ！他にも拡張しよう！！
  - ='\n'=      改行（Enter）のエスケープシークエンス
  - ='\t'=      タブ（Tab）のエスケープシークエンス他にもいろいろある（が、めったに使わない）

#+begin_src java -n :results output
class Main {
  public static void main(String[] args) {
    System.out.print('\t');
    System.out.print('a');
    System.out.print('\n');
  }
}
#+end_src

- Unicode
  - [[https://home.unicode.org/][Unicode – The World Standard for Text and Emoji]]


- Unicodeもエスケープシーケンス（の16進数）で表してしまえ！

#+begin_comment
  - ='\u3000'= みんな大好き全角のスペース
  - ='\u0027'=  シングルクォーテーションをUnicodeで
  - ='\u005C'=  バックスラッシュをUnicodeで
#+end_comment

#+begin_src java -n :results output
    System.out.print('\u2708');
    System.out.print('\uD392');
    System.out.print('\u0A09');
  #+end_src

#+RESULTS:

#+begin_note
16進数に用いるabcdefは大文字・小文字を問わない
#+end_note

- 空の文字はエラー
   - ''

#+begin_src java -n :results output
  System.out.println(''); // Error!!
#+end_src

#+RESULTS:

*** 参考：ASCIIコード表

- [[https://e-words.jp/p/r-ascii.html][ASCIIコード表 - IT用語辞典 e-Words]]

** 文字列の直値
*** 文字列の直値
:PROPERTIES:
:CUSTOM_ID: 文字列型の直値
:END:

- 文字列の直値
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.10.5][3.10.5.String Literals]]

- 文字列の直値はダブル・クォーテーションで囲む

| ="こんにちは"=                             | 「こんにちは」という文字列           |
| ="あけましておめでとう\nことしもよろしく"= | 改行を含んだ文字列                   |
| ="\u6771\u4eac"=                           | 「東京」のUnicode表現                |
| ="文字列は\"で囲む"=                       | ダブル・クォーテーションを含む文字列 |
| ="🥺"=                                     | 絵文字は1文字でも文字列（2文字相当） |
| =""=                                       | 空文字列（長さ0の文字列）            |

#+begin_src java :results output
class Main {
  public static void main(String[] args) {
    System.out.println("こんにちは");
    System.out.println("あけましておめでとう\nことしもよろしく");
    System.out.println("\u6771\u4eac");
    System.out.println("文字列は\"で囲む");
    System.out.println("文字は'で囲む");
    System.out.println("🥺");
    System.out.println("");
  }
}
#+end_src
#+begin_note
空文字（ =''= ）はエラーとなるが、空文字列（ =""= ）はエラーとならない。なぜだろう？
#+end_note

** ヌル値の直値
*** ヌル値

- ヌル値
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-3.html#jls-3.10.8][3.10.8.The Null Literal]]

- ヌル値とは？
  - 整数型の0に相当する
  - いわば参照型のための特殊な0の表現

#+begin_src java -n :results output
  System.out.println(null);
#+end_src

#+RESULTS:

* 変数の宣言・代入・参照・初期化と名前 :#05:
** 変数（Variable）とは？
:PROPERTIES:
:CUSTOM_ID: 変数variableとは
:END:

- 変数
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-4.html#jls-4.12][4.12. Variables]]

- 変数とは?
  - プログラムにおける情報の入れ物
- 代入とは?
  - 変数は代入をすることで値が変わる
- 参照とは?
  - 変数の値を読み出すこと
- 変数と型
  - 変数には型が与えられる
  - 異なる型の値は、代入できない

** 変数の宣言（declaration）

- 「変数を宣言する」とは？
  - 〇〇という *名前* で 〇〇という *型* の変数を用意してね、
    と指示すること
  - ある名前に「それは変数だよ」という意味を与えること

#+begin_src java :results output
  int i;        // 整数型のiという変数を宣言
  double pi;    // 倍精度実数型のpiという変数を宣言
  char ch;      // 文字型のchという変数を宣言
  boolean flag; // 真偽値型のflagという変数を宣言
#+end_src

#+RESULTS:

- 同じ型の変数を複数宣言することもできる

#+begin_src java :results output
  int i,j;
  double x,y,z;
#+end_src

- 宣言をしないで参照することはできない

#+begin_src java :results output
  System.out.println(ch); // Error!
#+end_src

#+RESULTS:

- 予約語を変数名にすることはできない

#+begin_src java :results output
  int class;      // classは予約語
  double public;  // publicは予約語
  boolean static; // staticは予約語
#+end_src

** 変数への代入（assignment）と参照（reference）
:PROPERTIES:
:CUSTOM_ID: 変数への代入assignmentと参照reference
:END:

- 代入
  - 宣言した変数に値を設定すること
- 参照
  - 変数の値を取得すること

#+begin_src java :results output
  int i;                 // 整数型の変数iを宣言
  i = 27;                // 変数iに27を代入
  System.out.println(i); // 変数iを参照
#+end_src

#+RESULTS:
: 27

** 変数の初期化（initialize）
:PROPERTIES:
:CUSTOM_ID: 変数の初期化initialize
:END:

- 変数を宣言したら、原則、その変数を *初期化* する
  - 初期化とは、変数を宣言して最初に行う代入
  - 代入する値を *初期値* という

- 変数を初期化する理由
  - 変数が参照できることを保証する
  - 宣言しただけの変数を参照することはできない

- 変数を初期化しないで参照してはならない
  - コンパイル時にエラーとなる

- 変数の宣言と初期化は同時に行うことができる

#+begin_src java :results output
  int x = 0;             // 変数xを宣言し初期化
  System.out.println(x); // 変数xを参照できる
#+end_src

#+RESULTS:
: 0

#+begin_src java :results output
  int x;                 // 変数xを宣言して初期化しない
  System.out.println(x); // 変数xを参照 -> Error!
#+end_src

#+RESULTS:

#+begin_src java :results output
  int x;                 // 変数xを宣言して初期化しない
  x = -1;                // 代入をすれば、
  System.out.println(x); // 変数xを参照 -> OK
#+end_src

#+RESULTS:
: -1

#+begin_src java :results output
  double pi = 3.14;       // 変数piを宣言し初期化
  System.out.println(pi); // 変数piを参照できる
#+end_src

#+RESULTS:
: 3.14

#+begin_src java :results output
  boolean flag = true;      // 変数flagを宣言し初期化
  System.out.println(flag); // 変数flagを参照できる
#+end_src

#+RESULTS:
: true

#+begin_src java :results output
  byte   b = 3;
  int    i = -11;
  long   l = 1245678901234567890L;
  float  f = 9.80665F;     // 標準重力加速度（m/s^2）
  double d = 2.99792458E8; // 真空中の高速（m/s）

  System.out.println(b);
  System.out.println(i);
  System.out.println(l);
  System.out.println(f);
  System.out.println(d);

  char ch = '字';
  boolean flag = true;

  System.out.println(ch);
  System.out.println(flag);
#+end_src

#+RESULTS:
: 3
: -11
: 1245678901234567890
: 9.80665
: 2.99792458E8
: 字
: true
: 文字列

- 宣言は一度だけしておけば、何度でも代入できる。

#+begin_src java :results output
  int i = 0;             // 変数iを宣言し初期化
  System.out.println(i); // 変数i = 0
  i = 1;                 // 変数iに代入
  System.out.println(i); // 変数i = 1
  i = 2;                 // 変数iに代入
  System.out.println(i); // 変数i = 2
#+end_src

- 複数の変数の宣言と初期化の方法
  - こういう方法もある、と

#+begin_src java :results output
  double x, y, z;
  x = y = z = 12.345;
  System.out.println(x);
  System.out.println(y);
  System.out.println(z);
#+end_src

#+RESULTS:
: 12.345
: 12.345
: 12.345

** 変数の名前空間（name space）
:PROPERTIES:
:ID:       e6588f26-a42f-490a-99dd-a86ee0aefce3
:END:

- 変数の「定義域」とも呼ばれる
  - その変数が有効な範囲
  - 変数の名前は「借り物」
    - 借りたものは必ず返す
    - そうでないと、同じ名前をプログラムの他の場所で利用したいときに困る

- 名前空間はブロックと一致する
  - あるブロックで定義した変数は、そのブロックが終了するまで有効
  - あるブロックで定義した変数は、内側のブロックでも有効
  - あるブロックで定義した変数は、外側のブロックでは無効

- 同じ名前の変数を、同じブロックで複数回宣言することはできない。

#+begin_src java :results output
  int i = 0;             // 変数iを宣言し初期化
  System.out.println(i); // 変数i = 0
  int i = 1;             // 変数iを再び宣言 -> Error!!
  System.out.println(i); // 変数i = 1
#+end_src

#+RESULTS:

#+begin_warning
この間違いは初心者あるあるなので注意！
#+end_warning

- ブロックが異なれば、同じ名前を使える（ブロック＝名前空間）。

#+begin_src java :results output
  {
      int i = 0;             // 変数iを宣言し初期化
      System.out.println(i); // 変数i = 0
  }
  {
      int i = 1;             // 変数iを再び宣言 -> OK
      System.out.println(i); // 変数i = 1
  }
#+end_src

#+RESULTS:
: 0
: 1

- 外側のブロックで宣言した変数は、内側でも使える。

#+begin_src java :results output
  {
      int out;
      {
          out = 10;
          System.out.println(out);
      }
  }
#+end_src

#+RESULTS:
: 10

- 内側のブロックで代入した値は外側で参照できる。

#+begin_src java :results output
  {
      int out;
      {
          out = -3;
      }
      System.out.println(out);
  }
#+end_src

#+RESULTS:
: -3

- 内側で宣言した変数は、外側では使えない。

#+begin_src java :results output
  {
      {
          int in = -10;
      }
      System.out.println(in); // Error!!
  }
#+end_src

#+RESULTS:

- 同じ名前の変数で上書きはできない
  （できても良いと思うのだが・・・）。

#+begin_src java -n :results output
  {
      int x = 1;
      {
          int x = -1 // Error!!
          System.out.println(x);
      }
      System.out.println(x);
  }
#+end_src

#+RESULTS:

** 変数の名前の付け方
:PROPERTIES:
:CUSTOM_ID: 変数の名前の付け方
:END:

- 変数名
  - 変数には必ず「名前」をつける（＝命名）
  - 変数名は識別子である

- 命名規則（コーディング規約）
  - Java
    - [[https://techacademy.jp/magazine/36131][Javaの命名規則を現役エンジニアが解説【初心者向け】 | TechAcademyマガジン]]
  - Python
    - [[https://pep8-ja.readthedocs.io/ja/latest/][はじめに — pep8-ja 1.0 ドキュメント]]
  - Ruby
    - [[https://techracho.bpsinc.jp/hachi8833/2017_02_13/35364#3-02][Rubyスタイルガイドを読む: 命名｜TechRacho by BPS株式会社]]

- 変数の名前の付け方には規則がある
  - 基本的にはアルファベットと数字（アンダースコア等の記号は使わない）
  - 先頭はアルファベット小文字
  - ２つ以上の単語を使うときは、単語の先頭だけをアルファベット大文字にする
    - ○ hello
    - ○ helloWorld
    - ○ helloWorld2
    - × 2helloWorld
    - × Hello
    - × hello_world

- スネークケース vs キャメルケース
  - [[https://designsupply-web.com/media/development/4052/][命名規則「キャメルケース」「スネークケース」「ケバブケース」についてまとめてみました]]

- これらの規則に違反してもエラーにはならない
  - あくまでも人間のためのルール
- 守らないとどうなるか？
  - 「こいつJavaわかってないんじゃね？・・・」と言われるダケ

- 変数名にはUnicodeを用いることもできるが、非推奨

#+begin_src java :results output
  double π = 3.14;
  System.out.println(π);
  int 日本語 = 10;
  System.out.println(日本語);
  // int 😜❤🤷 = -99; // Error!!
#+end_src

#+RESULTS:
: 3.14
: こんにちは

** COMMENT サンプルプログラム

1. 変数の定義・初期化・参照\\
   [[https://repl.it/@ychubachi/Variable1][Repl.it - Variable1]]
2. 複数の変数の定義・初期化・参照\\
   [[https://repl.it/@ychubachi/Variable2][Repl.it - Variable2]]
3. 変数を定義しないで使うと？\\
   [[https://repl.it/@ychubachi/Variable3][Repl.it - Variable3]]
4. 変数を初期化しないで使うと？\\
   [[https://repl.it/@ychubachi/Variable4][Repl.it - Variable4]]
5. 予約語を使うと？\\
   [[https://repl.it/@ychubachi/Variable5][Repl.it - Variable5]]
6. 同じ定義域で同じ名前の変数を定義すると？\\
   [[https://repl.it/@ychubachi/Variable6][Repl.it - Variable6]]
7. ブロックで名前空間を変えると？\\
   [[https://repl.it/@ychubachi/Variable7][Repl.it - Variable7]]
8. 入れ子になった名前空間\\
   [[https://repl.it/@ychubachi/Variable8#Main.java][Repl.it - Variable8]]
9. 変数の定義と初期化を同時に行う方法\\
   [[https://repl.it/@ychubachi/Variable9][Repl.it - Variable9]]

* 式の評価と数値の演算 :#06:
** 式の評価

- 式（Expression）
  - 計算式
  - [[https://docs.oracle.com/javase/specs/jls/se18/html/jls-15.html#jls-15.8][15. Expressions]]

- 式の評価（Evaluation）
  - 式を計算すること

- 文のなかに「式」が埋め込まれる
  - 次の「1 + 2」が式

#+begin_src java :results output
System.out.println(1 + 2);
#+end_src

- 式を評価するとは？
  - 計算の結果で式を置き換える

#+begin_src java :results output
System.out.println(3);
#+end_src

** 変数の評価
- 変数の評価
  - 変数の値を参照し変数を置き換えること

#+begin_src java :results output
  int x = 123;
  System.out.println(x);
#+end_src

#+RESULTS:
: 123

- 変数を評価する

#+begin_src java :results output
  System.out.println(123);
#+end_src

#+RESULTS:
: 123

** 数値の演算
- 整数の加算・減算・乗算

#+begin_src java :results output
  System.out.println(1 + 2);
  System.out.println(3 - 4);
  System.out.println(5 * 6);
#+end_src

#+RESULTS:
: 3
: -1
: 30

- 整数の除算

#+begin_src java :results output
  System.out.println(5 / 3); // 商
  System.out.println(5 % 3); // 余
#+end_src

#+RESULTS:
: 1
: 2

#+begin_src java :results output
    System.out.println(43871028 / 732); // 商
    System.out.println(43871028 % 732); // 余
    System.out.println(59933 * 732 + 72); // 検算
#+end_src

#+RESULTS:
: 59933
: 72
: 43871028

- 実数の加算・減算・乗算（他方が整数であれば実数に変換）

#+begin_src java :results output
  System.out.println(2 * 3.14 * 5.7);
  System.out.println(0.1 + 0.9);
  System.out.println(2 - (1.9 + 3.2));
  System.out.println(6.+.6);
#+end_src

#+RESULTS:
: 35.796
: 1.0
: -3.0999999999999996
: 6.6

- 実数の除算（割る数・割られる数のどちらかが実数）

#+begin_src java :results output
  System.out.println(5.0 / 3);
  System.out.println(2 / .037);
  System.out.println(1e+7 / 10); // 1e+7 = 10,000,000
#+end_src

#+RESULTS:
: 1.6666666666666667
: 54.054054054054056
: 1000000.0

- 実数の計算の例

#+begin_src java :results output
    System.out.println(5 / 3);
    System.out.println(5 % 3);

    System.out.println(5.0 / 3);
    System.out.println(5D / 3);
    System.out.println(5F / 3);

    System.out.println(5.0 % 2.5);
#+end_src

#+RESULTS:
: 1
: 2
: 1.6666666666666667
: 1.6666666666666667
: 1.6666666
: 0.0

** 変数の演算と結果の代入

- 変数の値を参照し、計算結果を別の変数に格納

#+begin_src java :results output
  int height = 7;
  int width = 3;
  int area = height * width;
  System.out.println(area);
#+end_src

#+RESULTS:
: 21

- 変数の値を参照し、計算結果を同じ変数に格納

#+begin_src java :results output
  int x = 5;
  System.out.println(x);
  x = x * 7;
  System.out.println(x);
#+end_src

#+RESULTS:
: 5
: 35

- インクリメント・デクリメント演算子

#+begin_src java :results output
  int i = 3;
  System.out.println(i);
  i ++; // i = i + 1
  System.out.println(i);
  i --; // i = i - 1
  System.out.println(i);

  // helloWorldILoveYou = helloWorldILoveYou + 1;
  // helloWorldILoveYou ++;
#+end_src

#+RESULTS:
: 3
: 4
: 3

- 代入演算子

#+begin_src java :results output
  int i = 3;
  System.out.println(i);
  i += 2; // i = i + 2;
  System.out.println(i);
  i -= 1; // i = i - 1;
  System.out.println(i);
  i *= 3; // i = i * 3;
  System.out.println(i);
  i /= 4; // i = i / 4;
  System.out.println(i);
#+end_src

#+RESULTS:
: 3
: 5
: 4
: 12
: 3

#+begin_comment
- 文字の計算（int型の文字コードに変換）;

#+begin_src java :results output
  char a = 'A';
  System.out.println(a);
  int i = a;
  System.out.println(i);
#+end_src

#+RESULTS:
: A
: 65

- 参考：文字で表示させたいならば
  - =(char)= の意味は後ほど取り扱う

#+begin_src java :results output
  char a = 'A';
  int b = a + 1;
  int c = a + 2;
  System.out.println((char)b);
  System.out.println((char)c);
#+end_src

#+RESULTS:
#+end_comment

** COMMENT サンプル

- 加減乗除と剰余
  - [[https://repl.it/@ychubachi/Operator1][Repl.it - Operator1]]
- 加減乗除と剰余＋インクリメント（increment）・デクリメント（decrement）\\
  [[https://repl.it/@ychubachi/Operator2][Repl.it - Operator2]]
- 文字列変数の演算\\
  [[https://repl.it/@ychubachi/StringOperator1][Repl.it -
  StringOperator1]]

- Javaには文字列に使える演算子には「+」しかない
- もし、「-*/」も使えるようにしたら、どのような機能になるだろうか？

* 論理演算・比較演算 :#07:
:PROPERTIES:
:ID:       280201c5-55c5-4e7c-b67a-e818184c0734
:END:

** 論理演算子（logical operators）
- 真偽値（boolean型の値）に対して行う演算

  #+begin_src java :results output
    System.out.println(true);
    System.out.println(false);
  #+end_src

- 否定（not）

| a     | !a    |
| true  | false |
| false | true  |

#+begin_src java :results output
  System.out.println(!true);
  System.out.println(!false);
#+end_src

#+RESULTS:
: false
: true

- 論理積（and）

| a     | b     | a && b |
| true  | true  | true   |
| true  | false | false  |
| false | true  | false  |
| false | false | false  |

#+begin_src java :results output
  System.out.println(true && true);
  System.out.println(true && false);
  System.out.println(false && true);
  System.out.println(false && false);
#+end_src

#+RESULTS:
: true
: false
: false
: false

- 論理和（or）

| a     | b     | a\vert{}\vert{}b  |
| true  | true  | true  |
| true  | false | true  |
| false | true  | true  |
| false | false | false |

#+begin_src java :results output
  System.out.println(true || true);
  System.out.println(true || false);
  System.out.println(false || true);
  System.out.println(false || false);
#+end_src

#+RESULTS:
: true
: true
: true
: false

- 変数（boolean型）を用いることもできる

#+begin_src java :results output
  boolean f1 = true;
  boolean f2 = false;
  System.out.println( !f1);
  System.out.println( f1 && f2);
  System.out.println( f1 || f2);
#+end_src

#+RESULTS:
: false
: false
: true

*** COMMENT サンプルコード

- [[https://repl.it/@ychubachi/Lun-Li-Yan-Suan-Zi-logical-operators][Repl.it -
  論理演算子（logical operators）]]

** 比較演算子（comparison operators）

# 左辺と右辺の値を比較し、その結果をtrue／falseで返します。一般的には、制御構文と合わせて利用します。

| 演算子 | 概要                           | *例*     |
|--------+--------------------------------+--------|
| ==     | 左辺と右辺が等しければtrue     | 5 == 5 |
| !=     | 左辺と右辺が等しくなければtrue | 5 != 5 |
| <      | 左辺が右辺より小さければtrue   | 5 < 7  |
| <=     | 左辺が右辺以下であればtrue     | 5 <= 3 |
| >      | 左辺が右辺より大きければtrue   | 7 > 5  |
| >=     | 左辺が右辺以上であればtrue     | 5 >= 7 |

- 等しい（==）

#+begin_src java :results output
  System.out.println( 3 == 3 );
  System.out.println( 3 == 5 );
  System.out.println( true == true);
  System.out.println( true == false);
#+end_src

#+RESULTS:
: true
: false
: true
: false

- 等しくない（!=）

#+begin_src java :results output
  System.out.println( 3 != 3 );
  System.out.println( 5 != 5 );
  System.out.println( true != true);
  System.out.println( true != false);
#+end_src

#+RESULTS:
: false
: false
: false
: true

- より小さい（小なり） （<）
#+begin_src java :results output
  System.out.println( 2 < 3 );
  System.out.println( 2 < -3 );
#+end_src

#+RESULTS:
: true
: false

- 以下（<=）

#+begin_src java :results output
  System.out.println( 2 <= 3 );
  System.out.println( 2 <= -3 );
#+end_src

#+RESULTS:
: true
: false

- より大きい（大なり） （>）
#+begin_src java :results output
  System.out.println( 2 > 3 );
  System.out.println( 2 > -3 );
#+end_src

#+RESULTS:
: false
: true

- 以上（>=）
#+begin_src java :results output
  System.out.println( 2 >= 3 );
  System.out.println( 2 >= -3 );
#+end_src

#+RESULTS:
: false
: true

- 変数を用いることもできる

#+begin_src java :results output
  int i = 8;
  int j = -3;
  System.out.println( i == 8);
  System.out.println( i + j == 5);
  System.out.println( i < 10);
  System.out.println( i >= j);
#+end_src

#+RESULTS:
: true
: true
: true
: true

- 比較演算の結果をboolean型の変数に代入できる

#+begin_src java :results output
  boolean flag = 3 < 5;
  System.out.println(flag);
#+end_src

** 比較演算子と論理演算子の組み合わせ
:PROPERTIES:
:CUSTOM_ID: 比較演算子と論理演算子の組み合わせ
:END:

- 比較演算子と論理演算子は組み合わせて使うことができる
  - 比較演算の結果は真偽値（trueかfalseのどちらか）
  - よって、論理演算（andやor、not）と組み合わせられる

- 比較演算子の組み合わせ

#+begin_src java :results output
  System.out.println(true == true );
  System.out.println( 2 < 5 );
  System.out.println(( 2 < 5 ) == true );
#+end_src

#+RESULTS:
: true
: true
: true

- 論理演算子との組み合わせ

#+begin_src java :results output
  System.out.println((2 < 3) && ( 3 < 4));
  System.out.println((2 < 3) || ( 3 <= 4));
#+end_src

#+RESULTS:
: false
: false
: true
: true

#+begin_note
値を比較演算子で評価した結果はboolean型となる。一方、論理演算子はboolean型同士の演算をする。これらを組み合わせて、より複雑な論理式を作ることができる。

プログラムは細かいパーツの組み合わせである。「演算子による計算結果は数値だね、そしたら、比較演算子と組み合わせられるね！」、「比較演算子の比較結果は真偽値だね、そしたら、論理演算子でいくつも組み合わせられるね！」という組み合わせの発想が大切となる。
#+end_note

#+begin_warning
比較演算子は基本型にしか使えない（と覚えておこう）。例えば、文字列型の値を比較する際に ==== を使うと、予期しない結果になることがある。コンパイルは通るので、間違うと深刻なバグの原因となり得る。なお、文字列型には比較をするための専用の方法があるので、別途、解説する。
#+end_warning

- 変数と組み合わせる

#+begin_src java :results output
  int score = 95;
  System.out.println(score > 60);
#+end_src

#+RESULTS:
: true

- 少し複雑な例

#+begin_src java :results output
    int average = (87 + 63 + 76 + 91) / 4;
    System.out.println(average);
    System.out.println(average >= 60);
#+end_src

#+RESULTS:
: 79
: true

- 次のコードはエラー
  - 理由を知りたい人は「Java 演算子 優先順位」で検索

#+begin_src java :results output
System.out.println(! 10 > 5);
#+end_src

*** COMMENT サンプルコード
:PROPERTIES:
:CUSTOM_ID: サンプルコード-1
:END:

- [[https://repl.it/@ychubachi/Bi-Jiao-Yan-Suan-Zi-comparison-operators][Repl.it -
  比較演算子（comparison operators）]]

#+begin_src java :results output
 double x, y;
    x = 2.23;
    y = 2.24;

    /*
    // 等しい
    System.out.println( 1    == 1    );
    System.out.println( x    == y    );
    System.out.println( true == false);

    // 等しくない
    System.out.println( 1    != 1    );
    System.out.println( x    != y    );
    System.out.println( true != false);

    // より小さい（小なり）
    System.out.println( 2 <  3 );
    System.out.println( 2 <  2 );
    System.out.println( 2 < -3 );
    System.out.println( x <  y );

    // 以下
    System.out.println( 2 <=  3 );
    System.out.println( 2 <=  2 );
    System.out.println( 2 <= -3 );
    System.out.println( x <=  y );

    // より大きい（大なり）
    System.out.println( 2 >  3 );
    System.out.println( 2 > -3 );
    System.out.println( x >  y );

    // 以上
    System.out.println( 2 >=  3 );
    System.out.println( 2 >= -3 );
    System.out.println( x >=  y );
    */

    // 計算式との組み合わせ
    int i = 28;
    int j = 17;
    System.out.println( (i % 2) == 0 ); // 偶数？
    System.out.println( (j % 2) == 0 ); // 偶数？
#+end_src

*** COMMENT サンプルコード
:PROPERTIES:
:CUSTOM_ID: サンプルコード-2
:END:

- [[https://repl.it/@ychubachi/Bi-Jiao-Yan-Suan-Zi-toLun-Li-Yan-Suan-Zi-noZu-miHe-wase#Main.java][Repl.it -
  比較演算子と論理演算子の組み合わせ]]

#+begin_src java :results output
    int i =  6;
    int j = -2;


    /*
    // 0より大きく、かつ、5以下
    System.out.println( ( 0 < i ) && ( i <= 5 ) );
    System.out.println( ( 0 < j ) && ( j <= 5 ) );
    // System.out.println( 0 < i <= 5 ); // ×

    // 0以下、または、5より大きい
    System.out.println( i <= 0 || 5 < i );
    System.out.println( j <= 0 || 5 < j );
    */

    // 「0より大きく、かつ、5以下」でない
    System.out.println( !( 0 < i && i <= 5 ) );
    System.out.println( !( 0 < j && j <= 5 ) );
    // System.out.println( i <= 0 || 5 < i );
    // System.out.println( 0 >= i || i > 5 );
  }
#+end_src

* 型変換 :#08:
** 型変換（type casting）

- 異なる型の値同士を変換することができる
  - これを *型変換（型キャスト）* と言う

- 基本型で扱える数値の範囲
  - byte < short < char < int < long < float < double
- 参照
  - [[id:7a14f8e2-ac0f-4fd0-86ad-e5e0121b8781][Javaの基本型（primitive type）]]

** 拡大変換（widening conversion）
:PROPERTIES:
:ID:       5a6f235d-22ca-4dca-a16c-cdd2c57093ee
:END:

- 拡大変換
  - 小さな型を大きな型に変換すること
  - 例） int から long， byte から float

- 暗黙的型変換（Implicit type conversion）
  - 拡大変換はどのような場合も上手くいく
  - プログラマーが変換せよと指示しなくても、暗黙的に行われる

#+begin_src java :results output
  int i = 65536;
  long l = i;
  System.out.println(i);
  System.out.println(l);
#+end_src

#+RESULTS:
: 65536
: 65536

#+begin_src java :results output
  float f = 3.14F;
  double d = f;
  System.out.println(f); // 3.14
  System.out.println(d); // 3.140000104904175
#+end_src

#+RESULTS:
: 3.14
: 3.140000104904175

#+begin_src java :results output
  int i = 123456;
  double d = i;
  System.out.println(i); // 123456
  System.out.println(d); // 123456.0
#+end_src

#+RESULTS:
: 123456
: 123456.0

#+RESULTS:

- char型からの変換時は、文字コード（数値）として扱われる

#+begin_src java :results output
  char c = 'A';
  int i = c;
  System.out.println(i); // 65
#+end_src

#+RESULTS:
: 65

#+begin_note
大は小を兼ねる！
#+end_note

# - まとめ

# #+begin_src java :results output
#       byte   b = -17;
#       short  s = b;
#       int    i = s;
#       long   l = i;
#       float  f = l;
#       double d = f;
#       System.out.println(b);
#       System.out.println(s);
#       System.out.println(i);
#       System.out.println(l);
#       System.out.println(f);
#       System.out.println(d);
# #+end_src

# #+RESULTS:
# : -17
# : -17
# : -17
# : -17
# : -17.0
# : -17.0

** 縮小変換（narrowing conversion）

- 型変換がうまくいかない場合（大きな型から小さな型への変換）
  - *コンパイル時にエラー* になる。

#+begin_src java :results output
  short s = 654;
  byte b = s; // Error!
  System.out.println(s);
  System.out.println(b);
#+end_src

#+RESULTS:

#+begin_src java :results output
  double d = 3.14;
  int i = d; // Error!
  System.out.println(d);
  System.out.println(i);
#+end_src

#+RESULTS:

- 縮小変換
  - 大きな型を小さな型に変換すること
  - 例） long から int， double から float

- 縮小変換が上手くできる場合
  - 変換先の型に収まる値かどうか

- 例
  - int型の300はshortに変換できるか？
    - shortの範囲は-32768～32767なので、OK
  - int型の50000はshortに変換できるか？
    - short型の範囲に収まらないので、NG
  - double型の3.14はintに変換できるか？
    - 小数点以下の値が格納できないので、NG

- 縮小変換をプログラムで行う場合、 *明示的に* 記述する
  - すべての場合を考えるとうまくいかないけど、この場合についてはうまくいく、ということをプログラマーがコンパイラーに指示すること

- 例
  - 今使っている型はint型であるが、中身は~128～127の範囲に収まるので、byte型に変換しても差し支えない
  - 今使っている方はdouble型であるが、その整数部分だけをint型に収めたい

- 明示的型変換（Explicit type conversion）
  - 大きな型から小さな型への変換は問題が発生する場合がある
  - プログラマーがそれを知った上で意図的に型変換することを「明示的型変換」という

- 型変換の明示法
  - 型の名前を()で囲む
  - コンパイルエラーはでなくなるが、 期待通りに変換できているかプログラマが注意する必要がある

#+begin_src java :results output
  int i = 100;
  byte b = (byte) i;
  System.out.println(b);
#+end_src

#+RESULTS:
: 100

- 桁溢れ（over flow）する場合

#+begin_src java :results output
    // 00000000 ~ 11111111 (2進数)
    // -128     ~ 127 (10進数)
    // 11111111 + 1 = 100000000 (9bit)
    int i = 128;
    byte b = (byte) i;
    System.out.println(b);
#+end_src

#+RESULTS:
: -128

#+begin_src java :results output
  double pi = 3.14;
  int i = (int) pi;
  System.out.println(i);
#+end_src

#+RESULTS:
: 3

#+begin_src java :results output
  double d = 1.0E36;
  float f = (float)d;
  System.out.println(f);
#+end_src

#+RESULTS:
: 1.0E36

- 直感と異なる型変換が行われる場合
  - 期待通りかどうかはその時次第

#+begin_src java :results output
  int i = 128;
  byte b = (byte) i;
  System.out.println(b); // -128
#+end_src

#+RESULTS:
: -128

#+begin_src java :results output
  double d = 1.0E39;
  float f = (float) d;
  System.out.println(f); // Infinity
#+end_src

#+RESULTS:
: Infinity

#+begin_src java :results output
  double d = 1.0E36;
  int i = (int)d;
  System.out.println(i); // 2147483647
#+end_src

#+RESULTS:
: 2147483647

- 文字コードから文字への変換

#+begin_src java :results output
  int i = 66;
  char c = (char)i;
  System.out.println(c); // B
#+end_src

#+RESULTS:

* 文字列型（String） :#09:
** 文字列型
:PROPERTIES:
:CUSTOM_ID: section-3
:END:

- 文字列型は参照型（reference type）に分類される型である。
  - 基本型（primitive type）ではない。

- 参照型は、基本型の組み合わせで作られる
  - プログラマが自ら定義することができる
  - Java言語には多くの型が予め用意されている（library)
  - 文字列型以外にもいっぱいある（配列型とか、ファイル型とか・・・）

- 参照型の名前の最初の文字は「アルファベット大文字」になっている
  - 基本型は小文字

| データ型             | データそのもののbit数 | 範囲                    |
| String（ストリング） | 不定（大きさは可変）  | Unicode文字（char）の列 |

- 文字列の直値を文字列型の変数に代入

#+begin_src java :results output
  String str = "こんにちは";
  System.out.println(str);
#+end_src

#+begin_src java :results output
  String str = "文字列";   // 変数strを宣言し初期化
  System.out.println(str); // 変数strを参照できる
#+end_src

#+RESULTS:
: 文字列

-  長さ0の文字列を代入する

#+begin_src java :results output
  String str = ""; // 空文字列
  System.out.println(str);
#+end_src

#+RESULTS:
:

- 参照型である文字列型にはnullを代入できる

#+begin_src java :results output
  String str = null;
  System.out.println(str);
#+end_src

#+begin_note
""は長さ0の文字列が *ある* ことを示すのに対し、null文字列は文字列が *ない* ことを示す。
#+end_note

** 文字列の演算
:PROPERTIES:
:CUSTOM_ID: 文字列の演算
:END:

- 文字列の加算
  - 文字列は「+」演算子で加算（連結; concatinate）ができる

#+begin_src java :results output
  String a = "Hello";
  String b = "World";
  String str = a + b;
  System.out.println(str);
#+end_src

#+RESULTS:
: HelloWorld

#+begin_src java :results output
    String a = "Hello";
    String b = "World";
    String space = " ";
    String str = a + space + b;
    System.out.println(str);
#+end_src

#+RESULTS:
: Hello World

- 文字列の引算・乗算・除算はできない

#+begin_src java :results output
  String a = "Hello";
  String b = "World";
  // System.out.println(a - b); // Error!!
  // System.out.println(a * 2); // Error!!
  // System.out.println(a / b); // Error!!
#+end_src

#+RESULTS:

- 文字列と基本形の加算
  - 一方が文字列であれば、もう一方は *文字列に変換* される
  - これは文字列の加算（連結）の際に行われる特別な、型の拡大変換である

#+begin_src java :results output
  int a = 2750;
  String b = "円";
  String str = a + b;
  System.out.println(str);
#+end_src

#+RESULTS:
: 2750円

#+begin_note
  - そもそもすべての数値（int型、double型など）は文字列に変換できるようになっている
  - そうでなければ結果を画面に表示できない
#+end_note

#+begin_src java :results output
  String a = "$";
  double b = 3.75;
  String str = a + b;
  System.out.println(str);
#+end_src

#+RESULTS:
: $3.75

#+begin_src java :results output
  char a = '$';
  double b = 3.75;
  String str = a + b; // Error
#+end_src

#+RESULTS:

#+begin_src java :results output
  int x = 3 * 7;
  System.out.println("3*7=" + x);
#+end_src

#+RESULTS:
: 3*7=21

#+begin_src java :results output
  int  i = 3776;
  char c = '㍍';
  System.out.println("富士山の高さは" + i + c);
#+end_src

#+RESULTS:
: 富士山の高さは3776㍍

#+begin_src java :results output
    double pi = 3.1415926534;
    String s1 = "π=";
    String s2 = s1 + pi;
    System.out.println(s2);
#+end_src

#+RESULTS:
: π=3.1415926534

#+begin_src java :results output
    double pi = 3.1415926534;
    String s1 = "" + pi;
    System.out.println(s1);
#+end_src

#+RESULTS:
: 3.1415926534

#+begin_src java :results output
    char a = '$';
    double b = 3.75;
    double c = a + b;
    System.out.println(c);
#+end_src

#+RESULTS:
: 39.75

#   String str = "文字列";
#   System.out.println(str);

#   String 日本語 = "こんにちは";
#   System.out.println(日本語);

# - 次はエラーになる（なぜ？）

# #+begin_src java :results output
#   String hello = "文字列";
#   System.out.println(hallo); // Error
# #+end_src

# #+RESULTS:

** 文字列オブジェクトと操作


# ここらでオブジェクト、クラス、インスタンスの話をする？
# - 整数や実数に対する加算と、文字列の加算は性質が異なる

- オブジェクト（object）とは？
  - オブジェクトとは操作の対象となる *もの*
  - 文字列もオブジェクトである

- 文字列オブジェクトに対して操作する（operate）ための方法（method）がある
  ー 加算（concatenate）も操作（method）の一つ

#+begin_note
  情報をオブジェクトとして取り扱うことがオブジェクト指向言語の特徴
#+end_note

- 文字列の加算（連結）をよりオブジェクト指向らしく表現すると次の通り。

#+begin_src java :results output
  String s1 = "abc";
  String s2 = "def";
  String s3 = s1.concat(s2); // s1 + s2 と同じ意味
  // String s3 = s2.concat(s1); // 結果が逆になる
  System.out.println(s3);
#+end_src

#+RESULTS:
: abcdef

- ドット表記（dot notitation）
  - =object.method()= という表現でオブジェクトを操作できる
  - dotとはピリオド記号のこと
  - 日本語の助詞「の」だと理解しておいて大体OK
  - ドット表記以外に主に簡略化のための別の表記法もある
    - 文字列を結合する「＋演算子」も文字列に対する操作

- 引数（argument）
  - オブジェクトを操作するために追加で必要な情報
  - =object.method(arg1, arg2)= のように，操作に応じて必要な引数の数は異なる

* 文字列の比較や長さ :#10:
** 文字列オブジェクトの比較

- 文字列の内容が等しいことを調べる操作（equals）
  - 基本型における ====

#+begin_src java :results output
  String str1 = "ABC";
  String str2 = "ABC";
  System.out.println(str1.equals(str2));
#+end_src

#+RESULTS:
: true

- =equals= と ==== の違い

#+begin_src java :results output
  String str1 = "あいうえお";
  String str2 = "あいうえお";
  String str3 = "あい";
  str3 = str3 + "うえお";

  System.out.println(str1 == str2);
  System.out.println(str1 == str3);

  System.out.println(str1.equals(str2));
  System.out.println(str1.equals(str3));
#+end_src

#+RESULTS:
: true
: false
: true
: true

#+begin_warning
文字列の比較にはequals()を使うこと！
#+end_warning

** 文字列オブジェクトの長さに関連する操作

- 文字列の長さを求める操作（length）

#+begin_src java :results output
  String str = "あいうえお";
  System.out.println(str.length());
  str = "ふるいけやかわずとびこむみずのおと";
  System.out.println(str.length());
#+end_src

#+RESULTS:
: 5
: 17

- 文字列から文字を取り出す操作（charAt）
  - 先頭の文字は0番目と数える

#+begin_src java :results output
  String str = "あいうえお";
  char ch = str.charAt(0); // char型
  System.out.println(ch);
#+end_src

#+RESULTS:
: あ

- 文字列の長さを超えて取り出すことはできない

#+begin_src java :results output
    String str = "あいうえお";
    char ch = str.charAt(5);
    System.out.println(ch);
#+end_src

#+RESULTS:

- 文字列から部分文字列を取り出す操作（substring）

#+begin_src java :results output
  String str = "あいうえお";
  String sub = str.substring(1);
  System.out.println(sub);
#+end_src

#+RESULTS:
: いうえお

- 任意の範囲

#+begin_src java :results output
    String str = "０１２３４５６７８９";
    String sub = str.substring(3, 6);
    System.out.println(sub);
#+end_src

#+RESULTS:
: ３４５

** 文字列オブジェクトの様々な操作

- 様々な文字列の操作
  - [[https://java-code.jp/189][length／codePointCountメソッド]]
  - [[https://java-code.jp/783][isEmptyメソッド]]
  - [[https://java-code.jp/185][charAtメソッド]]
  - [[https://java-code.jp/187][indexOf／lastIndexOfメソッド]]
  - [[https://java-code.jp/183][equals／equalsIgnoreCaseメソッド]]
  - [[https://java-code.jp/788][regionMatchesメソッド]]
  - [[https://java-code.jp/181][compareTo／compareToIgnoreCaseメソッド]]
  - [[https://java-code.jp/179][trimメソッド]]
  - [[https://java-code.jp/177][startsWith／endsWithメソッド]]
  - [[https://java-code.jp/793][toLowerCase／toUpperCaseメソッド]]
  - [[https://java-code.jp/795][substringメソッド]]
  - [[https://java-code.jp/797][replaceメソッド]]
  - [[https://java-code.jp/799][splitメソッド]]
  - [[https://java-code.jp/801][joinメソッド]]
  - [[https://java-code.jp/173][formatメソッド]]

- その他の操作
  - [[https://docs.oracle.com/javase/jp/8/docs/api/java/lang/String.html][String (Java Platform SE 8 )]]

** COMMENT プログラムとは、言葉に意味を付ける作業

#+begin_src java :results output
  System.out.println("Hello World");
#+end_src

#+RESULTS:
: Hello World

#+begin_src java :results output
  String greeting = "Hello World";
  System.out.println(greeting);
#+end_src

#+RESULTS:
: Hello World

** COMMENT 文字列型のナゾ
:PROPERTIES:
:CUSTOM_ID: 文字列型のナゾ
:END:

1. 基本型ではなく「参照型」
2. 定義するときは大文字（String）で始まる識別子
3. ＋演算子の挙動が基本型と違う
4. 文字列で扱えるBit数は不定
5. そもそも参照って何を参照しているのか？\\
   ・・・

** COMMENT 文字列型の変数が参照型である理由
:PROPERTIES:
:CUSTOM_ID: 文字列型の変数が参照型である理由
:END:

- 文字列型の変数は「文字列（というモノ）」を参照している
  - 文字列自体は長さが様々（bit数が不定）

- 文字列が存在する場所（address）であれば
  - 値そのものはメモリーのどこか（Javaが管理）においといて、その場所だけ変数に格納する

- 場所だけならbit数は固定で表せることができる
  - 一昔前のパソコンのようにメモリーが4Gバイトなら32bitの変数で参照可能
  - 今時のパソコンは8G、16Gなどもっとメモリーが多いので64bitの変数を使う

** ここまでで作れるプログラムの例（参考）

#+begin_src java :results output
class Main {
  public static void main(String[] args) {
    double taijuu = 80.0;
    double shinchou = 1.7;

    double bmi = taijuu / (shinchou * shinchou);
    System.out.println("あなたのBMIは" + bmi + "です");
    System.out.println("普通体重？ = " + ((18.5 <= bmi) && (bmi < 25.0)));
  }
}
#+end_src

#+RESULTS:
: あなたのBMIは27.68166089965398です
: 普通体重？ = false

* 配列型（Array） :#11:
** 配列とは？

- *配列* とは？
  - 同じ型の値を複数個まとめて取り扱うための仕組み
  - 配列にある一つ一つの値を *要素（element）* という

- 配列の長さ
  - 配列には *長さ（length）* がある
  - 長さは0以上、メモリの限界まで

- 配列の要素
  - 配列の要素には0番から配列の長さ-1番までの *番号（index）* が振られる
  - 番号を用いて要素に代入や参照できる

** 配列変数の宣言

- 型名に =[]= をつける

#+begin_src java :results output
  int[] iArray;
  double[] dArray;
  char[] chArray;
  String[] strArray;
#+end_src

#+RESULTS:

** 配列変数の初期化（配列の直値）

- 配列変数の初期化
  - 配列の要素に代入すること

- 配列の直値表現
  - 同じ型の直値を「{」「}」で括り，「,」で区切って並べる

- 宣言と同時に初期化する際、配列の直値表現で初期化できる。

#+begin_src java :results output
  int[] iArray = {0, 1, 2, 3};
  double[] dArray = {1, 1.414, 1.732, 2, 2.236};
  char[] chArray = {'あ','い','う', 'A', 'B'};
  String[] strArray = {"こんにちは", "さようなら", "ありがとう", "おやすみ"};
#+end_src

#+RESULTS:

** 配列の要素を参照する

- 配列変数に番号をつけて参照できる

#+begin_src java :results output
  int[] iArray = {0, 1, 2, 3};
  System.out.println(iArray[0]);
  System.out.println(iArray[3]);
#+end_src

#+RESULTS:
: 0
: 3

#+begin_src java :results output
  String[] strArray = {"こんにちは", "さようなら", "ありがとう", "おやすみ"};
  System.out.println(strArray[2]);
  System.out.println(strArray[3]);
#+end_src

#+RESULTS:
: ありがとう
: おやすみ

- 番号が長さを超えた場合
  - *実行時例外* になる

#+begin_src java :results output
  double[] dArray = {1, 1.414, 1.732, 2, 2.236};
  System.out.println(dArray[5]); // 実行時に例外
  System.out.println(dArray[-1]); // 実行時に例外
#+end_src

#+RESULTS:

** 配列の要素に代入する

- 代入もできる

#+begin_src java :results output
  char[] chArray = {'あ','い','う', 'A', 'B'};
  chArray[1] = 'わ';
  System.out.println(chArray[1]);
#+end_src

#+RESULTS:
: わ

** 変数を用いた要素の指定
- 番号に整数型の変数を用いることができる

#+begin_src java :results output
  double[] dArray = {1, 1.414, 1.732, 2, 2.236};
  int i = 0;
  System.out.println(dArray[i]);
  i++;
  System.out.println(dArray[i]);
#+end_src

#+RESULTS:
: 1.0
: 1.414

#+begin_note
  変数で要素を指定して代入・参照できることこそ配列の重要な利点。
  後に「繰り返し」と組み合わせる。
#+end_note

** 多次元配列

- 2次元以上の配列を作ることができる
  - 225次元までらしい
    - [[https://docs.oracle.com/javase/jp/8/docs/api/java/lang/reflect/Array.html][Array (Java Platform SE 8 )]]

#+begin_src java :results output
  int[][] image = {{1,0,1},
                   {0,1,0},
                   {1,0,1}};
  System.out.println(image[0][2]);
  System.out.println(image[1][1]);
#+end_src

#+RESULTS:
: 1
: 1

** 配列の長さ（length）

- ドット表記で配列の長さを求めることができる

#+begin_src java :results output
  int[] array = {2, 3, 5, 7, 11, 13, 17, 19};
  System.out.println(array.length);
#+end_src

#+RESULTS:
: 8

- 二次元配列の長さ

#+begin_src java :results output
  int[][] image = {{1,0,1,0},
                   {0,1,0,1},
                   {1,0,1,1}};
  System.out.println(image.length);
  System.out.println(image[0].length);
#+end_src

#+RESULTS:
: 3
: 4

#+RESULTS:

#+begin_warning
  文字列の場合、 =length()= であるのに対して、配列は =length= 。
  あきらかに紛らわしい。どうしてそうなったかは知らぬ。
  Java言語を開発したデザイナーが決めたことである。
#+end_warning

** 配列を文字列に変換する（Arrays.toString()）
- 配列はオブジェクト？
  - オブジェクトである
  - しかしながら、配列そのものをオブジェクトとしてドット表記で
     メソッドを呼び出すことはあまりない

- Arraysオブジェクト
  - 配列を操作するためのオブジェクト

- 配列を文字列に変換する

#+begin_src java :results output
  int[] array = {2, 3, 5, 7, 11, 13, 17, 19};
  System.out.println(Arrays.toString(array));
#+end_src

#+RESULTS:
: [2, 3, 5, 7, 11, 13, 17, 19]

- 要素が変更されたことを確認

#+begin_src java :results output
  int[] array = {2, 3, 5, 7, 11, 13, 17, 19};
  array[3] = 0;
  System.out.println(Arrays.toString(array));
#+end_src

#+RESULTS:
: [2, 3, 5, 0, 11, 13, 17, 19]

- 多次元配列の場合

#+begin_src java :results output
  int[][] image = {{1,0,1,0},
                   {0,1,0,1},
                   {1,0,1,1}};
  System.out.println(Arrays.deepToString(image));
#+end_src

#+RESULTS:
: [[1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 1]]

* 構造化プログラミング1
** プログラムの制御構造
*** 条件分岐とジャンプ
- 条件分岐
  - ある条件を満たすかどうかでプログラムの制御の流れを変更すること
- ジャンプ
  - 条件が成立したとき、プログラムの一部を飛ばす
- スパゲッティプログラム
  - ジャンプをむやみに使うことで、プログラムが読みづらくなる

*** 構造化プログラミング（Structured programming）
:PROPERTIES:
:CUSTOM_ID: 構造化プログラミングstructured-programming
:END:

- ジャンプを使わず、「順次、選択、反復、サブルーチンがあればどんなプログラムでも書けますよ」
  - このプログラミング手法の普及に貢献したのは、1968年の計算機科学者エドガー・ダイクストラ（Edsger Wybe Dijkstra）によるACM機関紙への投書「Go To Statement Considered Harmful」と言われている

- Go To Statementとは？
  - プログラムの任意の位置に移動する機能（ジャンプ）

- これらに加え、現代的なプログラミング言語には例外処理の機構がある
  - 用途を限定した Go To Statement である

*** 構造化プログラミングの制御構文
:PROPERTIES:
:CUSTOM_ID: 構造化プログラミングの制御構文
:END:

1. 順次（sequence）
   - ステートメントまたはブロックステートメントを順々に処理する
2. 選択（selection）
   - 条件式の結果に従って次に実行するステートメントまたはブロックを選択してフロー分岐する
3. 反復（repetition）
   - 特定の状態の間、ステートメントまたはブロック内を繰り返す
   - 状態の確認は反復起点時または反復終点時の二通りある
4. サブルーチン（subroutine）
   - これをコールした次のステートメントに復帰（return）する事を前提にして対象ブロックの起点にジャンプする
   - 終点に達すると自動的に復帰する他、任意の途中位置でも復帰できる
5. 例外処理（Exception Handling）
   - プログラムの過程で計算の実行が不可能になった場合、例外が発生したと扱い、例外処理のための記述にジャンプする

#+begin_comment
Javaの制御構文

- [[https://java-code.jp/84][if命令]]
- [[https://java-code.jp/82][switch命令]]
- [[https://java-code.jp/80][while命令]]
- [[https://java-code.jp/78][do...while命令]]
- [[https://java-code.jp/76][for命令]]
- [[https://java-code.jp/74][拡張for命令]]
- [[https://java-code.jp/72][break命令]]
- [[https://java-code.jp/70][continue命令]]
- try/catch
#+end_comment

** 順次（sequence）とは？
:PROPERTIES:
:CUSTOM_ID: 順次sequenceとは
:ID:       64383a6c-cd35-4a82-bae1-89491119398b
:END:

- 順次構造で文をつなげる
  - 文は必ず上から下へ、順番に次々実行される

#+BEGIN_SRC plantuml :file ./image/sequence1.png :exports results
@startuml
start
:Statement 1;
:Statement 2;
:Statement 3;
end
@enduml
#+END_SRC

#+NAME:fig-sequence1
#+RESULTS:
[[file:./image/sequence1.png]]

- Javaによる表現
  - 各々の文は「;」で区切る

#+begin_src java :results output
  int a = 3;
  int b = a * 4;
  System.out.println(b);
#+end_src

#+RESULTS:
: 12

- 複合文（ブロック）
  - 文が複数個集まり、複合文という一つの文になる

#+BEGIN_SRC plantuml :file ./image/sequence2.png  :exports results
@startuml
start
group Block A
  :Statement 1;
  :Statement 2;
end group
end
@enduml
#+END_SRC

#+RESULTS:
[[file:./image/sequence2.png]]

#+BEGIN_SRC plantuml :file ./image/sequence3.png :exports results
@startuml
start
group Block B
  :Statement 3;
  :Statement 4;
  :Statement 5;
end group
end
@enduml
#+END_SRC

#+RESULTS:
[[file:./image/sequence3.png]]

- Block AとBlock Bを順次でつなぐ

#+BEGIN_SRC plantuml :file ./image/sequence4.png :exports results
@startuml
start
:**Block A**;
:**Block B**;
end
@enduml
#+END_SRC

#+RESULTS:
[[file:./image/sequence4.png]]

- Javaによる表現

#+begin_src java :results output
  {
      System.out.println("Block A");
  }
  {
      System.out.println("Block B");
  }
#+end_src

#+RESULTS:
: Block A
: Block B

** 選択（selection）とは？
:PROPERTIES:
:CUSTOM_ID: 選択selectionとは
:END:

*** 条件分岐
- 選択は「条件分岐（conditional branch）」とも呼ばれる（こちらが一般的）
  - ある条件を満たすかどうかで文を実行するか、あるいは、どの文を選択して実行するかを判断する

- 条件は値が真偽値となる *式*
  - [[id:280201c5-55c5-4e7c-b67a-e818184c0734][論理演算・比較演算]] 参照

*** 二股に分岐する選択

- 変数flagがboolean型であるとき
  - flagが真（true）ならばStatementを実行する
  - falseならば実行しない
- 条件が成立したときに実行するブロックをthenブロックという

#+BEGIN_SRC plantuml :file ./image/selection1.png :exports results
@startuml
start
if (cond) then (true)
  group **then** block
    :Statement;
  end group
else (false)
endif
end
@enduml
#+END_SRC

#+RESULTS:
[[file:./image/selection1.png]]

- Java言語での表現
  - if文を用いる

#+begin_src java :results output
  System.out.println("start");
  if(true) {
      System.out.println("true");
  }
  System.out.println("end");
#+end_src

#+RESULTS:
: start
: true
: end

- 条件にboolean型の変数を用いる場合

#+begin_src java :results output
  boolean flag = true;

  System.out.println("start");
  if(flag) {
      System.out.println("true");
  }
  System.out.println("end");
#+end_src

- 条件に論理演算を用いる場合

#+begin_src java :results output
  System.out.println("start");
  if(false || true) {
      System.out.println("true");
  }
  System.out.println("end");
#+end_src

#+RESULTS:
: start
: true
: end

- 条件に比較演算を用いる場合

#+begin_src java :results output
  System.out.println("start");
  if(0 < 1) {
      System.out.println("true");
  }
  System.out.println("end");
#+end_src

#+RESULTS:
: start
: true
: end

*** elseブロックのある選択

- flagが偽（false）のときに実行する文がある場合
  - 二股に分岐する
- 条件が不成立のときに実行するブロックをelseブロックと言う。

#+BEGIN_SRC plantuml :file ./image/selection2.png :exports results
@startuml
start
if (cond) then (true)
  group **then** block
    :Statement;
  end group
else (false)
  group **else** block
    :Statement;
  end group
endif
end
@enduml
#+END_SRC

#+RESULTS:
[[file:./image/selection2.png]]
- Java言語での表現

#+begin_src java :results output
  boolean flag = true;
  System.out.println("start");
  if(flag) {
      System.out.println("then block");
  } else {
      System.out.println("else block");
  }
  System.out.println("end");
#+end_src

#+RESULTS:
: start
: then block
: end

- 多段階に分岐する場合
 - if文のthenブロックやelseブロックに更にif文を埋め込む

#+BEGIN_SRC plantuml :file ./image/selection3.png :exports results
@startuml
start
if (cond1) then (true)
    :**Block A**;
else (false)
  if (cond2) then (true)
    :**Block B**;
  else (false)
    if (cond3) then (true)
      :**Block C**;
    else (false)
        :**Block D**;
    endif
  endif
endif
end
@enduml
#+END_SRC

#+RESULTS:
[[file:./image/selection3.png]]

- Java言語での表現

#+begin_src java :results output
  boolean cond1 = false;
  boolean cond2 = false;
  boolean cond3 = true;

  System.out.println("start");
  if(cond1) {
      // Block A
      System.out.println("cond1=true");
  } else {
      System.out.println("cond1=false");
      if(cond2) {
          // Block B
          System.out.println("cond2=true");
      } else {
          System.out.println("cond2=false");
          if(cond3) {
              // Block C
              System.out.println("cond3=true");
          } else {
              // Block D
              System.out.println("cond3=false");
          }
      }
  }
  System.out.println("end");
#+end_src

#+RESULTS:
: start
: cond1=false;
: cond2=false
: cond3=true
: end

- =else if=
  - ブロックの中に更にブロックをどんどん埋め込んでいくと、ネストが深くなる
  - 全体の構造がわかりにくい
  - =else if= により、これを避ける

#+BEGIN_SRC plantuml :file ./image/selection4.png :exports results
@startuml
!pragma useVerticalIf on
start
if (cond1) then (true)
  :**Block A**;
elseif (cond2) then (true)
  :**Block B**;
elseif (cond3) then (true)
  :**Block C**;
else (else)
  :**Block D**;
endif
stop
@enduml
#+END_SRC

#+RESULTS:
[[file:./image/selection4.png]]

#+begin_comment
if a then b
  if c then d
else e

if a then b
  if c then d
  else e

#+end_comment

- Java言語での表現

#+begin_src java :results output
  boolean cond1 = true;
  boolean cond2 = true;
  boolean cond3 = true;

  System.out.println("start");
  if(cond1) {
      // Block A
      System.out.println("cond1=true");
  } else if(cond2) {
      // Block B
      System.out.println("cond2=true");
  } else if(cond3) {
      // Block C
      System.out.println("cond3=true");
  } else {
      // Block D
      System.out.println("other");
  }
  System.out.println("end");
#+end_src

#+RESULTS:
: start
: cond1=true
: end

*** 3つ以上に分岐する場合（switch文）

- =if/else/else if= の他、 =switch= 文もある

#+begin_src java :results output
  int i = 1;
  switch (i) {
  case 1:
      System.out.println("one");
      break;
  case 2:
      System.out.println("two");
      break;
  case 3:
      System.out.println("three");
      break;
  default:
      System.out.println("default");
      break;
  }
#+end_src

#+RESULTS:
: one

*** COMMENT サンプルプログラム

- [[https://repl.it/@ychubachi/Tiao-Jian-Fen-Qi-1#Main.java][Repl.it -
  条件分岐1]]
- [[https://repl.it/@ychubachi/Tiao-Jian-Fen-Qi-else][Repl.it -
  条件分岐（else）]]
- [[https://repl.it/@ychubachi/Tiao-Jian-Fen-Qi-Ru-reZi][Repl.it -
  条件分岐（入れ子）]]
- [[https://repl.it/@ychubachi/Tiao-Jian-Fen-Qi-Fu-Shu-noFen-Qi-Xian][Repl.it -
  条件分岐（複数の分岐先）]]

** 反復（repetition）
:PROPERTIES:
:ID:       003dca48-4e0a-4f2f-9d4e-d5a7e61ae306
:END:

*** 反復とは？
- 一般的には「繰り返し（loop）」と呼ぶ
- ある条件を満たしている間、同じ文を繰り返す
  - 条件判定を文を実行する前に行う方法（前判定）と、文を実行した後に行う方法（後判定）がある

*** 反復の記述方法
- 前判定の反復
  - 継続条件を反復の始まりで判定する

#+BEGIN_SRC plantuml :file ./image/repetition1.png :exports results
@startuml
start
while (cond1) is (true)
  :**Block**;
endwhile (false)
stop
@enduml
#+END_SRC

#+RESULTS:
[[file:./image/repetition1.png]]
- 後判定の反復
  - 継続条件を反復の終わりで判定する
  - あまり使わない

#+BEGIN_SRC plantuml :file ./image/repetition2.png :exports results
@startuml
start
repeat
  :**Block**;
repeat while (cond1) is (true)
stop
@enduml
#+END_SRC

#+RESULTS:
[[file:./image/repetition2.png]]

*** Javaによる表現
- 無限反復（無限ループ）
  - 継続条件が常にtrueなので、無限にブロックを繰り返す
  - 後で説明する break 文で抜け出すことは可能

#+begin_src java :results output
  while (true) {
    System.out.println("Hello world");
  }
#+end_src

#+RESULTS:
: Hello

- 継続条件がfalseの場合
  - ブロックは実行されない
  - elseブロックのないif文と同じ

#+begin_src java :results output
  while (false) {
    System.out.println("Hello world");
  }
#+end_src

- 指定回数繰り返す方法
  - 回数を数えるための変数（カウンタ）を初期化
  - 継続条件でカウンタを判定する
  - ブロックの最後でカウンタを更新する

#+begin_src java :results output
  int i = 0;      // カウンタを初期化
  while (i < 5) { // カウンタを判定
    System.out.println("Hello world");
    i ++;         // カウンタを更新
  }
#+end_src

#+RESULTS:
: Hello world
: Hello world
: Hello world
: Hello world
: Hello world

- 初期値2から2づつ進ませる
  - カウンタを画面に表示する

#+begin_src java :results output
  int i = 2;
  while (i <= 10) {
    System.out.println("i=" + i);
    i += 2;
  }
#+end_src

#+RESULTS:
: i=2
: i=4
: i=6
: i=8
: i=10

- マイナス方向にカウント

#+begin_src java :results output
  int i = -1;
  while (-20 < i) {
    System.out.println("i=" + i);
    i *= 2;
  }
#+end_src

#+RESULTS:
: i=-1
: i=-2
: i=-4
: i=-8
: i=-16

* 構造化プログラミング2 :#12:

** 反復の続き

*** 反復を用いた配列の処理
- 配列のすべての要素を参照
  - 継続条件は、カウンタが配列のlength未満

#+begin_src java :results output
  int[] array = {73, 92, 88, 81, 65};
  int i = 0;
  while (i < array.length) {
    System.out.println(array[i]);
    i ++;
  }
#+end_src

#+RESULTS:
: 73
: 92
: 88
: 81
: 65

- 文字列配列のすべての要素を表示
  - 継続条件は、カウンタiが配列のlength未満

#+begin_src java :results output
  String[] array = {"はじめまして", "こんにちは", "さようなら", "ありがとう"};
  int i = 0;
  while (i < array.length) {
    System.out.println(array[i]);
    i ++;
  }
#+end_src

#+RESULTS:
: はじめまして
: こんにちは
: さようなら
: ありがとう

- 配列の値を合計する

#+begin_src java :results output
   int[] array = {73, 92, 88, 81, 65};
   int sum = 0; // 合計を格納する変数
   int i = 0;
   while (i < array.length) {
       sum += array[i];
       i ++;
   }
  System.out.println("sum=" + sum);
#+end_src

#+RESULTS:
: sum=399

- 配列の値を平均する

#+begin_src java :results output
  int[] array = {73, 92, 88, 81, 65};
  int sum = 0; // 合計を格納する変数
  int i = 0;
  while (i < array.length) {
      sum += array[i];
      i ++;
  }

  // 平均を計算する
  double average = (double) sum / array.length;
  System.out.println("average=" + average);
#+end_src

#+RESULTS:
: average=79.8


*** for文

- 前判定の反復
  - カウンタの初期化
  - 継続条件
  - カウンタの更新
- for文はこれらをまとめて表現できる

#+begin_src java :results output
  String[] array = {"はじめまして", "こんにちは", "さようなら", "ありがとう"};
  int i = 0;                 // カウンタの初期化
  while (i < array.length) { // 継続条件
    System.out.println(array[i]);
    i ++;                    // カウンタの更新
  }
#+end_src

#+RESULTS:
: はじめまして
: こんにちは
: さようなら
: ありがとう

#+begin_src java :results output
  String[] array = {"はじめまして", "こんにちは", "さようなら", "ありがとう"};
  for(int i = 0; i < array.length; i++) { // 初期化・継続条件・更新
    System.out.println(array[i]);
  }
#+end_src

#+RESULTS:
: はじめまして
: こんにちは
: さようなら
: ありがとう

#+begin_note
for文はwhile文を書きやすくするための糖衣構文（Syntax sugaro）である。
ただし、カウンタ変数の定義域はfor文のブロック内となる。
#+end_note


*** 後判定（repeat文）

- repeat文
  - ブロックを必ず１回実行する
  - 継続条件を判定し、継続する場合再度ブロックを実行

#+begin_src java :results output
  int i = 0; // i = 10とすると？
  while (i < 5) {
      System.out.println("こんにちは");
      i ++;
  }
#+end_src

#+RESULTS:
: こんにちは
: こんにちは
: こんにちは
: こんにちは
: こんにちは

#+begin_src java :results output
  int i = 0; // i = 10とすると？
  do {
      System.out.println("こんにちは");
      i ++;
  } while (i < 5);
#+end_src

#+RESULTS:
: こんにちは
: こんにちは
: こんにちは
: こんにちは
: こんにちは

- 前判定と後判定の使い分け
  - よく使うのは前判定
  - 後判定が有効なのはわりと特殊であるが、ここぞというときに使えると格好が良い

*** break文/continue文

- break文
  ｰ 反復の途中で抜け出す

#+begin_src java :results output
  int[] array = {2, 3, -1, 5, 6};
  int i = 0;
  while (i < array.length) {
      System.out.println(array[i]);
      if (array[i] == -1) {
          break;
      }
      i ++;
  }
#+end_src

#+RESULTS:
: 2
: 3
: -1

- continue文
  - それ以降のブロックの実行をしない
  - for文と組み合わせることが多い

#+begin_src java :results output
  int[] array = {2, 3, -1, 5, 6};
  for (int i = 0; i < array.length; i ++) {
      if (array[i] == -1) {
          continue;
      }
      System.out.println(array[i]);
  }
#+end_src

#+RESULTS:
: 2
: 3
: 5
: 6

- while文で使うと、カウンタの変更をしないので注意

#+begin_src java :results output
  int[] array = {2, 3, -1, 5, 6};
  int i = 0;
  while (i < array.length) {
      if (array[i] == -1) {
          i ++; // 必要
          continue;
      }
      System.out.println(array[i]);
      i ++;
  }
#+end_src

#+RESULTS:
: 2
: 3
: 5
: 6

* 構造化プログラミング3 :#13:
** 応用：サイコロを振り6が出るまで繰り返す

- =Math.random()= メソッド
  - 0.0以上1.0未満の乱数を返す
- サイコロの作り方
  - 6をかけて1を足し、intに型変換すると1~6までの数が得られる

#+begin_src java :results output
  double ransuu = Math.random();
  System.out.println("乱数=" + ransuu);
  int saikoro = ((int) (ransuu * 6)) + 1;
  System.out.println("サイコロ=" + saikoro);
#+end_src

#+RESULTS:
: 乱数=0.46708576698913284
: サイコロ=3

#+begin_src java :results output
  int saikoro = 0;
  while (saikoro != 6) {
      double ransuu = Math.random();
      System.out.println("乱数=" + ransuu);
      saikoro = ((int) (ransuu * 6)) + 1;
      System.out.println("サイコロ=" + saikoro);
  }
#+end_src

#+RESULTS:
#+begin_example
乱数=0.6657104638267204
サイコロ=4
乱数=0.36540713664136615
サイコロ=3
乱数=0.41942965433131285
サイコロ=3
乱数=0.8001997841394504
サイコロ=5
乱数=0.0780758769162695
サイコロ=1
乱数=0.22825452251895473
サイコロ=2
乱数=0.5052832654202659
サイコロ=4
乱数=0.21001934812135759
サイコロ=2
乱数=0.9671402725500964
サイコロ=6
#+end_example

*** COMMENT サンプルプログラム
:PROPERTIES:
:CUSTOM_ID: サンプルプログラム-1
:END:

- [[https://repl.it/@ychubachi/Wu-Xian-rupu#Main.java][Repl.it - 無限ループ]]
- [[https://repl.it/@ychubachi/Zao-riFan-siHui-Shu-Zhi-Ding#Main.java][Repl.it - 繰り返し（回数指定）]]
- [[https://repl.it/@ychubachi/Zao-riFan-siPei-Lie-tonoZu-miHe-wase#Main.java][Repl.it - 繰り返し（配列との組み合わせ）]]
- [[https://repl.it/@ychubachi/Zao-riFan-siPei-Lie-noHe-Ji-Ping-Jun-Ji-Suan][Repl.it - 繰り返し（配列の合計・平均計算）]]
- [[https://repl.it/@ychubachi/Zao-riFan-siNi-Shun-niBiao-Shi][Repl.it - 繰り返し（逆順に表示）]]
- [[https://repl.it/@ychubachi/Zao-riFan-siHou-Zhi-Pan-Ding][Repl.it - 繰り返し（後置判定）]]
- [[https://repl.it/@ychubachi/Zao-riFan-siZhong-Zhi-Pan-Ding][Repl.it - 繰り返し（中置判定）]]

** 例外（Exception Handling）
*** 例外とは？
- 正常に処理が行えなくなった場合、例外を発生させる
  - 実行中のブロックを抜け、例外処理のブロックまでジャンプする
- 例外が発生する可能性のある処理を記述する場合
  - tryブロックで囲む
  - 例外が発生した場合に実行されるcatchブロックを記述
    - 発生した例外の理由などを知るための変数が利用可能

*** 例外の発生のさせかた
- 例外を発生させる方法
  - =throw new Exception()=

#+begin_src java :results output
  boolean flag = false;

  try {
      System.out.println("開始");
      if (flag) {
        System.out.println("ここで例外発生");
        throw new Exception("テスト");
      }
      System.out.println("正常に終了");
  } catch(Exception e) {
      System.out.println("処理がうまくいきませんでした");
      System.out.println("例外の理由：" + e.getMessage());
  }
#+end_src

#+RESULTS:
: 開始
: 正常に終了

*** 例：計算結果が例外を発生させる場合
- 整数を0で除算した場合、計算不能

#+begin_src java :results output
  int a = 12;
  int b = 3; // b = 0 で例外発生

  try {
      System.out.println("開始");
      int x = a / b;
      System.out.println("a / b =" + x);
      System.out.println("正常に終了");
  } catch(Exception e) {
      System.out.println("処理がうまくいきませんでした");
      System.out.println("例外の理由：" + e.getMessage());
  }
#+end_src

#+RESULTS:
: 開始
: a / b =4
: 正常に終了

*** 例：参照型の変数がnull型の場合
- メソッドを呼び出すと例外発生

#+begin_src java :results output
  String str = "文字列"; // str = null で例外発生

  try {
      System.out.println("開始");
      System.out.println("str.length()=" + str.length());
      System.out.println("正常に終了");
  } catch(Exception e) {
      System.out.println("処理がうまくいきませんでした");
      System.out.println("例外の理由：" + e.getMessage());
  }
#+end_src

#+RESULTS:
: なんらかの処理
: str.length()=3
: 正常に終了

*** 配列の範囲を超えた場合
- 配列の添字が要素数を超えている

#+begin_src java :results output
  int[] array = {1 , 2, 3};

  try {
      System.out.println("開始");
      System.out.println("array[0]=" + array[0]); // -1 や 3で例外発生
      System.out.println("正常に終了");
  } catch(Exception e) {
      System.out.println("処理がうまくいきませんでした");
      System.out.println("例外の理由：" + e.getMessage());
  }
#+end_src

#+RESULTS:
: 開始
: array[0]=1
: 正常に終了

*** 例外処理の省略
- 例外処理は省略できる場合とできない場合がある
  - 全てのブロックに例外処理を記述するのは鬱陶しい

- 例外処理が省略できる場合
  - 0での割り算
  - 変数がnullである時のメソッド呼び出し
  - 配列の範囲を超えた参照 など

- 必要な場合
  - 例外が起こり得る可能性の高い、特定のメソッドを呼び出す場合
  - ファイルやネットワークへのアクセス など

*** 実行時例外（Runtime Exception）の例（文字列型の場合）

- 文字列の長さを超えた場合

#+begin_src java :results output
  String str = "あいうえお";
  System.out.println(str.charAt(6));
#+end_src

#+RESULTS:

- オブジェクトがnullであった場合

#+begin_src java :results output
  String str = null;
  System.out.println(str.length()); // 実行できない
#+end_src

#+RESULTS:

** サブルーチン（subroutine）
*** サブルーチンとは？
:PROPERTIES:
:ID:       7a50e10d-4f1a-45dd-88f4-0e68502bf1c9
:END:

- サブルーチンは、Javaではメソッド（method）と言う
  - いままでもいくつかのメソッドを利用してきた
    - =System.out.println()=
    - 文字列に対する =length()= 等

*** メソッドを作成する
- メソッドは自分で作成することもできる
  1. ブロックに名前を付ける
  2. ブロックを様々な場所から呼び出す

- メソッドを作成する場所
  - **class** ブロックに作成する
  - mainブロックではない！
  - 実はmainブロックはメソッド

- 同じ内容を一つにまとめる
  - 一度書いたものを再利用する

#+begin_src java :results output
  class Main {
      public static void main(String[] args) {
          System.out.println("ふるいけや かわずとびこむ みずのおと");
          System.out.println("  それにつけても かねのほしさよ");

          System.out.println("めにあおば やまほととぎず はつがつお");
          System.out.println("  それにつけても かねのほしさよ");

          System.out.println("しずかさや いわにしみこむ せみのこえ");
          System.out.println("  それにつけても かねのほしさよ");
      }
  }
#+end_src

#+RESULTS:
: ふるいけや かわずとびこむ みずのおと
:   それにつけても かねのほしさよ
: めにあおば やまほととぎず はつがつお
:   それにつけても かねのほしさよ
: しずかさや いわにしみこむ せみのこえ
:   それにつけても かねのほしさよ

- 下の句をメソッドにすると、再利用できる。

#+begin_src java :results output
  class Main {
      public static void main(String[] args) {
          System.out.println("ふるいけや かわずとびこむ みずのおと");
          shimonoku(); // メソッドを呼び出す

          System.out.println("めにあおば やまほととぎず はつがつお");
          shimonoku(); // メソッドを呼び出す

          System.out.println("しずかさや いわにしみこむ せみのこえ");
          shimonoku(); // メソッドを呼び出す
      }

      static void shimonoku() { // メソッドのブロック
          System.out.println("  それにつけても かねのほしさよ");
      }
  }
#+end_src

#+RESULTS:
: ふるいけや かわずとびこむ みずのおと
:   それにつけても かねのほしさよ
: めにあおば やまほととぎず はつがつお
:   それにつけても かねのほしさよ
: しずかさや いわにしみこむ せみのこえ
:   それにつけても かねのほしさよ

*** メソッドに引数（arguments）を渡す方法
- 次の例で同じ箇所を再利用したい

#+begin_src java :results output
  class Main {
      public static void main(String[] args) {
          System.out.println("佐藤さん、こんにちは。");
          System.out.println("ごきげんいかがですか？");

          System.out.println("田中さん、こんにちは。");
          System.out.println("ごきげんいかがですか？");

          System.out.println("鈴木さん、こんにちは。");
          System.out.println("ごきげんいかがですか？");
      }
  }
#+end_src

#+RESULTS:
: 佐藤さん、こんにちは。
: ごきげんいかがですか？
: 田中さん、こんにちは。
: ごきげんいかがですか？
: 鈴木さん、こんにちは。
: ごきげんいかがですか？

- 名前（名字）以外は同じ
  - 同じものを一つにまとめたい
  - 名前を変数にすればよい。

- 変数はブロック内に作るものとする
  - 変数の定義域はブロック
  - 参照：[[id:e6588f26-a42f-490a-99dd-a86ee0aefce3][変数の名前空間（name space）]]

#+begin_src java :results output
  class Main {
      public static void main(String[] args) {
          {
              String name = "佐藤";
              System.out.println(name + "さん、こんにちは。");
              System.out.println("  ごきげんいかがですか？");
          }

          {
              String name = "田中";
              System.out.println(name + "さん、こんにちは。");
              System.out.println("  ごきげんいかがですか？");
          }

          {
              String name = "鈴木";
              System.out.println(name + "さん、こんにちは。");
              System.out.println("  ごきげんいかがですか？");
          }
      }
  }
#+end_src

#+RESULTS:
: 佐藤さん、こんにちは。
:   ごきげんいかがですか？
: 田中さん、こんにちは。
:   ごきげんいかがですか？
: 鈴木さん、こんにちは。
:   ごきげんいかがですか？

- 引数の種類
  - 実引数
    - メソッドを呼び出すときの値
  - 仮引数
    - メソッドが受け取る値を代入する変数

- 実引数は自動的に仮引数に代入される
  - ブロックを呼び出すとき、ブロックが使用する変数に自動的に代入される

#+begin_src java :results output
  class Main {
      public static void main(String[] args) {
          greeting("佐藤");
          greeting("田中");
          greeting("鈴木");
      }

      static void greeting(String name) {
          System.out.println(name + "さん、こんにちは。");
          System.out.println("  ごきげんいかがですか？");
      }
  }
#+end_src

#+RESULTS:
: 佐藤さん、こんにちは。
:   ごきげんいかがですか？
: 田中さん、こんにちは。
:   ごきげんいかがですか？
: 鈴木さん、こんにちは。
:   ごきげんいかがですか？

- 引数はいくつでも作れる
  - 実引数は値をカンマで区切る
  - 仮引数は変数宣言をカンマで区切る

#+begin_src java :results output
  class Main {
      public static void main(String[] args) {
          greeting("佐藤", true);
          greeting("田中", false);
          greeting("鈴木", true);
      }

      static void greeting(String name, boolean flag) {
          System.out.println(name + "さん、こんにちは。");
          System.out.println("  ごきげんいかがですか？");
          if (flag) {
              System.out.println("  こんど、遊びに行きましょう。");
          }
      }
  }
#+end_src

#+RESULTS:
: 佐藤さん、こんにちは。
:   ごきげんいかがですか？
:   こんど、遊びに行きましょう。
: 田中さん、こんにちは。
:   ごきげんいかがですか？
: 鈴木さん、こんにちは。
:   ごきげんいかがですか？
:   こんど、遊びに行きましょう。

*** メソッドを途中で抜ける

- メソッドのブロックから途中で抜けることができる
  - =reutrn= 文を使う

#+begin_src java :results output
  class Main {
      public static void main(String[] args) {
          greeting("佐藤", true);
          greeting("田中", false);
          greeting("鈴木", true);
      }

      static void greeting(String name, boolean flag) {
          System.out.println(name + "さん、こんにちは。");
          System.out.println("  ごきげんいかがですか？");
          if (!flag) {
              return; // メソッドのブロックから抜ける
          }
          System.out.println("  こんど、遊びに行きましょう。");
          return; // 最後のreturnは省略可能
      }
  }
#+end_src

#+RESULTS:
: 佐藤さん、こんにちは。
:   ごきげんいかがですか？
:   こんど、遊びに行きましょう。
: 田中さん、こんにちは。
:   ごきげんいかがですか？
: 鈴木さん、こんにちは。
:   ごきげんいかがですか？
:   こんど、遊びに行きましょう。

*** メソッドの戻り値
- メソッドで計算した結果を受け取ることができる
  - reutrn文に値を追加する

- メソッドに戻り値の型を指定する
  - return文で戻す値の型

- 戻り値は1つのみ
  - 引数は複数
- 戻り値には名前はない

#+begin_src java :results output
  class Main {
      public static void main(String[] args) {
          System.out.println("add(1, 3)=" + add(1, 3));
          System.out.println("add(5, 12)=" + add(5, 12));
          System.out.println("add(2, -7)=" + add(2, -7));
      }

      static int add(int a, int b) {
          return a + b;
      }
  }
#+end_src

#+RESULTS:
: add(1, 3)=4
: add(5, 12)=17
: add(2, -7)=-5

#+begin_src java :results output
  class Main {
      public static void main(String[] args) {
          System.out.println("bye(\"本田\")=" + bye("本田"));
          System.out.println("bye(\"松本\")=" + bye("松本"));
          System.out.println("bye(\"林\")=" + bye("林"));
      }

      static String bye(String name) {
          return name + "さん、ごきげんよう";
      }
  }
#+end_src

#+RESULTS:
: bye("本田")=本田さん、ごきげんよう
: bye("松本")=松本さん、ごきげんよう
: bye("林")=林さん、ごきげんよう

*** メソッドのまとめ

- メソッドの構造（input-process-output）
  - 入力：何らかの値を受け取る
  - 処理：値を用いて計算する
  - 出力：計算結果の値を引き渡す

- メソッドの定義
  - 出力する値の型（無い場合、void）
  - メソッドの名前（識別子）
  - 入力する値の名前と型（0個以上の引数）

- メソッドからの復帰
  - 任意の場所から復帰可能
  - 復帰の際、戻り値の値を指定する

*** サンプルプログラム

- [[https://repl.it/@ychubachi/mesotudoJia-Suan][Repl.it - メソッド（加算）]]
- [[https://repl.it/@ychubachi/mesotudoAi-Zan][Repl.it - メソッド（挨拶）]]

* 最終課題

** 課題について
- Javaプログラミングに関するレポートを提出
- 提出先
  - Googleクラスルーム
- 提出方法
  - Googleドキュメントでレポートを作成する
  - 学籍番号、氏名を記載すること
  - 課題と問題の番号、及び解答を記載すること

** 課題1

人間が計算機を作り、計算機科学を研究して発展させてきた背景には、人が手で計算することでは到底求められない数を正確に計算させたいという要求があった。

その代表的な数として円周率（π）がある。紀元前250頃、アルキメデスは幾何学的な計算により円周率は約3.14であることを求めた。時は流れ、18年初頭にマチンは100桁まで手計算で求めた。19世紀半ばシャンクスは707桁まで計算したが、死後、527桁より先の計算は間違いであることが判明した。

計算機を用いて最初に円周率が求められたのは1949年のことであった。ENIACという計算機を用いて円周率を求め2037桁計算した。計算にかかった時間は70時間ほどであったという。そして、2022年6月にグーグルは円周率を100兆桁まで求めたことを発表した。このように、計算機を用いると人間が手で行うことは不可能だと考えられる計算を行うことができる。

次のプログラムは「Leibniz」の公式により円周率を計算するプログラムである（ChatGPTが作成したものを改変）。現在、小数点1桁まで正しく計算できる。このプログラムをもとに、できるだけ多くの桁数を正確に求められるように改良しなさい。

なお、Java言語では予め、Math.PIという変数に円周率が代入されているので、これとの比較を行うことで、正しい桁数がわかる。

#+begin_src java :results output
  int terms = 100;

  double pi = 0.0;
  boolean positive = true;
  for (int i = 0; i < terms; i++) {
      int divisor = 2 * i + 1;
      if (positive) {
          pi += 1.0 / divisor;
      } else {
          pi -= 1.0 / divisor;
      }
      positive = !positive;
  }
  pi *= 4;

  System.out.println("Leibnizの公式 による円周率の近似値: " + pi);
  System.out.println("Math.PI       による円周率の近似値: " + Math.PI);
  #+end_src

#+RESULTS:
: Leibnizの公式 による円周率の近似値: 3.1315929035585537
: Math.PI       による円周率の近似値: 3.141592653589793

問題
- (1) 改良したプログラムのURL（repl.it）
- (2) プログラムをどのように変更したか？
- (3) 求められた桁数は小数点以下何桁か？
- (4) 苦労した点・工夫した点
- (5) この課題の感想

** 課題2

素数とは1とそれ自身の数以外では割り切れない整数である。小さい方から、2、3、5、7、13、17、19、23、29・・・と続く。全ての素数を導き出す公式は存在しないとされている。しかし、計算機で計算させることはできる。

ChatGPTに、100までの素数を求めるプログラムを作らせたところ、次のプログラムを得た（授業で習った範囲の知識に限定するために一部改変）。
また、計算にかかる時間をミリ秒で計測するためのコードを追加した（★で示した）。

このプログラムをもとに、できるだけ多くの素数を求めるように改良したい。

#+begin_src java :results output
    long startTime = System.currentTimeMillis(); // ★

    int n = 100;
    boolean[] primes = new boolean[n + 1]; // 0〜nまでの配列を用意

    for (int i = 2; i <= n; i++) {
        primes[i] = true;
    }

    for (int i = 2; i * i <= n; i++) {
        if (primes[i]) {
            for (int j = i * i; j <= n; j += i) {
                primes[j] = false;
            }
        }
    }

    long endTime = System.currentTimeMillis(); // ★
    System.out.println("\n" + n +
                       "までの素数を求める計算にかかった時間は"
                       + (endTime - startTime) + "ミリ秒です。");

    System.out.println("2 から " + n + " までの素数：");
    for (int i = 2; i <= n; i++) {
        if (primes[i]) {
            System.out.print(i + " ");
        }
    }
#+end_src

#+RESULTS:
:
: 100までの素数を求める計算にかかった時間は0ミリ秒です。
: 2 から 100 までの素数：
: 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97

問題
- (1) 改良したプログラムのURL（repl.it）
- (2) プログラムをどのように変更したか？
- (3) 求められた素数は何個か？
- (4) 苦労した点・工夫した点
- (5) この計算方法の名前は何か？
- (6) この課題の感想

** 課題３

コンピュータを利用すると、とても大きな数や、とても小さな数を用いた様々な計算を行うことができる。特に天文学の分野ではそのような数を用いた計算が必須である。まさに、「天文学的な数」を計算させることが求められる。

さて、一週間は、日、月、火、水、木、金、土の7日間である。それぞれの曜日は太陽系の天体と対応しているが、それぞれ大きさも重さもまちまちである。

そこで、全ての曜日の長さが等しく24時間になっているのは不自然だとは考えられないか？それぞれの天体のデータを調べ、次の問題に答えよ。結果と、計算のために作製したプログラムを示せ（repl.itのURL）。

なお、一週間全体の長さは24×7=168時間のままで変わらないものとする。

問題
- (1) 各曜日の長さが各天体の「直径」に比例すると考えた時、曜日ごとの時間はどうなるか？
- (2) 各曜日の長さが各天体の「体積」に比例すると考えた時、曜日ごとの時間はどうなるか？
- (3) 各曜日の長さが各天体の「質量」に比例すると考えた時、曜日ごとの時間はどうなるか？
- (4) 苦労した点・工夫した点
- (5) この課題の感想。

* COMMENT オブジェクト指向（参考）
** クラスとインスタンスとは？

- クラスとは情報の入れ物の「型」
   - インスタンスとは情報そのもの

- 文字列・配列のクラスとインスタンス

| クラス | インスタンス             |
|--------+--------------------------|
| String | "abc"                    |
| String | "あいうえお"             |
| String | "こんにちは\nさようなら" |
| Array  | {0, 1 , 2}               |
| Array  | {1, 1.414 , 1.732}       |
| Array  | {'x', 'y', 'z'}          |

** new 演算子

- new演算子を用いるとインスタンスを直値表現よりも柔軟に作成できる

- 文字列型の初期化

#+begin_src java :results output
  String str;
  str = new String();
#+end_src

#+RESULTS:

- 個数だけ指定し中身は空の配列の定義（new演算子を使う）

#+begin_src java :results output
  int[] i = new int[10];
  double[] d = new double[10];
  String[] str = new String[20];
#+end_src

#+RESULTS:

- 長さ1万の配列も作れる

#+begin_src java :results output
  int[] iArray = new int[10000];
#+end_src

#+RESULTS:

- 文字の配列から文字列を生成

#+begin_src java :results output
  char data[] = {'a', 'b', 'c'};
  String str = new String(data);
#+end_src

#+RESULTS:

* COMMENT 標準入出力
** 間接的な、値の入力
:PROPERTIES:
:CUSTOM_ID: 間接的な値の入力
:END:

- プログラムを（苦労して）作成する価値は大量の値を一気に計算できるから\\
  （あるいは複雑な計算を間違いなく何回も行わせることができるから）
- 今まで、値はプログラムのコードに直接書いた
  - 直値（literal）表現
- プログラムの外部から値を読み込ませてみよう
  - ここではキーボードから
  - 他、ファイル、インターネット、データベースなど

** 標準入力（standard input）と標準出力（standard output）
:PROPERTIES:
:CUSTOM_ID: 標準入力standard-inputと標準出力standard-output
:END:

- 大抵のプログラムでは次の入出力が利用できる
  - 標準入力は標準的に利用できる入力装置のことで通常はキーボード
  - 標準出力は画面など
    - System.out の out はここから来ている
  - 標準エラー出力（standar error）もあるがここでは割愛

** サンプルプログラム

- [[https://repl.it/@ychubachi/Biao-Zhun-Ru-Li-Zheng-Shu-Shi-Shu#Main.java][Repl.it -
  標準入力（整数・実数）]]
- [[https://repl.it/@ychubachi/Biao-Zhun-Ru-Li-Wen-Zi-Lie#Main.java][Repl.it -
  標準入力（文字列）]]
- [[https://repl.it/@ychubachi/Biao-Zhun-Ru-Li-Pei-Lie-Zao-riFan-si][Repl.it -
  標準入力（配列・繰り返し）]]

** この授業でやり残したこと
:PROPERTIES:
:CUSTOM_ID: この授業でやり残したこと
:END:

- 例外（exception）
- ファイル（file）

ここらへん、Java2でやると思うので、引き続き履修してね！

* COMMENT 緊急企画！「2020夏休み特別プログラミング塾開催」
:PROPERTIES:
:CUSTOM_ID: 緊急企画2020夏休み特別プログラミング塾開催
:END:

　先日、enPiTプログラムの追加募集につきましてアナウンスしましたが、残念ながら中止となりました。その代わりの企画として、希望者で夏休み期間中に「プログラミング塾」を開催します。

　内容は

- Java1授業の復習（と教材作成のお手伝い）
- Java2授業の予習（と教材作成のお手伝い）
- その他、各種プログラミングのお勉強など希望に応じて\\
  実際にアプリ開発までできるとよいですね！

参加希望者は中鉢（[[mailto:chubachi@cis.twcu.ac.jp][chubachi@cis.twcu.ac.jp]]）までメールで連絡をしてくだださい。実施方法等は参加希望者で相談しながら決めたいと思います。

　例）週1回、Meetでミーディング、課題と添削、など
